<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>トラブルシューティング</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" type="text/css" href="themes/packages/@vivliostyle/theme-techbook/theme.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
<section class="level1" aria-labelledby="トラブルシューティング"><h1 id="トラブルシューティング">トラブルシューティング</h1><section class="level2" aria-labelledby="ログ管理"><h2 id="ログ管理">ログ管理</h2><p>システム障害の問題解決をはかるトラブルシューティングを行う場合に、もっとも有益な情報源がログです。</p><p>ログには、OSが出力するログ、アプリケーションが出力するログなど多くの種類が存在します。</p><p>ここでは、代表的なログの種類と確認方法、設定方法などを解説します。</p><section class="level3" aria-labelledby="ログの種類"><h3 id="ログの種類">ログの種類</h3><p>CentOSでは、ログファイルは/var/logディレクトリ以下に格納されています。</p><p>以下は代表的なログファイルです。</p>
























<table><thead><tr><th>ファイル名</th><th>内容</th></tr></thead><tbody><tr><td>messages</td><td>サービス起動時の出力など一般的なログ</td></tr><tr><td>secure</td><td>認証、セキュリティ関係のログ</td></tr><tr><td>maillog</td><td>メール間連のログ</td></tr><tr><td>dmesg</td><td>カーネルが出力したメッセージのログ</td></tr></tbody></table></section><section class="level3" aria-labelledby="ログの確認"><h3 id="ログの確認">ログの確認</h3><p>サーバのログにサービス起動時、または動作時のエラーログが記録されていないかを確認します。また、クライアント側にもエラーログが記録されていないかを確認します。</p><ul>
<li>一般的なトラブルであれば、まずは/var/log/messagesを確認します。</li>
<li>認証関係やアクセス制限に関係するトラブルは/var/log/secureを確認します。</li>
<li>メール関係であれば/var/log/maillogを確認します。</li>
<li>Webサーバであれば/var/log/httpd/error_logなどを確認します。</li>
</ul></section><section class="level3" aria-labelledby="dmesgに記録されるログ"><h3 id="dmesgに記録されるログ">dmesgに記録されるログ</h3><p>dmesgコマンドは「display message」の略で、Linuxカーネルがメッセージを出力するリングバッファ（循環バッファ）の内容を表示します。このリングバッファは一定のサイズ内で循環するようになっており、古いログは消えていきます。<br>
dmesgコマンドを用いることにより、システム起動時に出力されるカーネルメッセージの確認ができます。カーネルが正しくハードウェアを認識しているかどうかを確認する場合などに参照します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">dmesg</span></span></span>
<span class="token output">Initializing cgroup subsys cpuset
Initializing cgroup subsys cpu
Linux version 2.6.32-504.el6.x86_64 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) ) #1 SMP Wed Oct 15 04:27:16 UTC 2014
Command line: ro root=/dev/mapper/vg_server-lv_root rd_LVM_LV=vg_server/lv_swap rd_NO_LUKS rd_LVM_LV=vg_server/lv_root rd_NO_MD crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=jp106 LANG=ja_JP.UTF-8 rd_NO_DM rhgb quiet
KERNEL supported cpus:
  Intel GenuineIntel
  AMD AuthenticAMD
  Centaur CentaurHauls
Disabled fast string operations
（略）</span></code></pre></section><section class="level3" aria-labelledby="syslogについて"><h3 id="syslogについて">syslogについて</h3><p>syslogは、カーネルやプログラムなどから出力されるログをまとめて記録する仕組みです。syslogを使うことで、各プログラムは独自にログを記録する仕組みを開発する必要が無くなります。また、syslogサーバをネットワーク上で動作させることで、複数のホストからのログをまとめて記録することで、ログを一元管理することもできます。<br>
CentOS 6では、syslogサーバとしてrsyslogが使用できます。</p><p>rsyslogは、従来のsyslogデーモン（syslogd）に置き換わる、マルチスレッドのsyslogデーモンです。rsyslog（Reliable syslog）という名前からも分かる通り、高い信頼性を実現するように開発されています。そのため、ログの転送にTCPを使用したり、データベースへのログ保存、暗号化したログの転送なども行うことができます。基本的な設定については、従来のsyslogdと互換性があります。</p></section><section class="level3" aria-labelledby="ファシリティとプライオリティ"><h3 id="ファシリティとプライオリティ">ファシリティとプライオリティ</h3><p>カーネルやプログラムが出力するsyslogメッセージには、「ファシリティ」（facility）と「プライオリティ」（priority）と呼ばれる値が設定されています。</p><p>ファシリティは、何がそのログメッセージを生成したのかを指定します。たとえば、カーネルやメールといった値が指定されます。</p><p>また、プライオリティはメッセージの重要性を指定します。たとえば、単なる情報、非常に危険な状態などといった値が指定されます。</p><p>ファシリティには、以下の種類があります。</p>




























































<table><thead><tr><th>ファシリティ</th><th>意味</th></tr></thead><tbody><tr><td>auth</td><td>セキュリティ・認証関連（login、su など）</td></tr><tr><td>authpriv</td><td>セキュリティ・認証関連（プライベート）</td></tr><tr><td>cron</td><td>cronやatのログ</td></tr><tr><td>daemon</td><td>一般的なデーモン（サーバプログラム）関連</td></tr><tr><td>kern</td><td>カーネル関連</td></tr><tr><td>lpr</td><td>プリンタ関連</td></tr><tr><td>mail</td><td>メール関連</td></tr><tr><td>news</td><td>NetNews関連</td></tr><tr><td>security</td><td>authと同じ</td></tr><tr><td>syslog</td><td>syslogd自身のログ</td></tr><tr><td>user</td><td>ユーザアプリケーションのログ</td></tr><tr><td>uucp</td><td>uucp転送を行うプログラムのログ</td></tr><tr><td>local0からlocal7</td><td>独自のプログラムで利用可能なfacility</td></tr></tbody></table><p>プライオリティには、以下の種類があります。</p>
























































<table><thead><tr><th>プライオリティ</th><th>意味</th></tr></thead><tbody><tr><td>debug</td><td>デバッグ用メッセージ</td></tr><tr><td>info</td><td>一般的な情報メッセージ</td></tr><tr><td>notice</td><td>通知メッセージ</td></tr><tr><td>warning</td><td>警告メッセージ</td></tr><tr><td>warn</td><td>warningと同じ</td></tr><tr><td>err</td><td>一般的なエラーメッセージ</td></tr><tr><td>error</td><td>errと同じ</td></tr><tr><td>crit</td><td>ハード障害などの危険なエラーメッセージ</td></tr><tr><td>alert</td><td>システム破損などの緊急事態</td></tr><tr><td>emerg</td><td>非常に危険な状態</td></tr><tr><td>panic</td><td>emergと同じ</td></tr><tr><td>none</td><td>ファシリティを無効にする</td></tr></tbody></table></section><section class="level3" aria-labelledby="syslogサーバの設定"><h3 id="syslogサーバの設定">syslogサーバの設定</h3><p>syslogサーバの設定ファイルである/etc/rsyslog.confには、受け取ったログメッセージをファシリティとプライオリティの組み合わせでどのファイルに出力するかの設定が記述されています。</p><p>記述は以下の形式となります。</p><pre class="language-text"><code class="language-text">ファシリティ.プライオリティ アクション</code></pre><p>syslogサーバの設定ファイル中で、複数のファシリティを指定したい場合には、「,」（コンマ）で区切ります。たとえば、UUCP転送とメール関連のファシリティを同時に指定したい場合には、以下のように指定します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">uucp,news.crit /var/log/spooler</span></code></pre><p>syslog設定ファイル中でプライオリティを指定すると、そのプライオリティ以上の重要度のプライオリティがすべて当てはまります。たとえば、以下のように設定したとします。</p><pre class="language-text"><code class="language-text">mail.warning</code></pre><p>mailファシリティからのwarning以上（err、crit、alert、emerg）のすべてのプライオリティが当てはまります。</p><p>特定のプライオリティのみ指定したい場合には、「=プライオリティ」と指定します。</p><pre class="language-text"><code class="language-text">mail.=warning</code></pre><p>この指定はmailファシリティのプライオリティがwarningのメッセージのみが当てはまります。</p><p>noneファシリティはやや特殊な動きをするので、後述の例で解説します。</p></section><section class="level3" aria-labelledby="アクションの設定"><h3 id="アクションの設定">アクションの設定</h3><p>ファシリティとプライオリティを記述した右側に、該当するログをどうするかを指定するアクションを記述します。</p><p>主なアクションは、以下の表のとおりです。</p><section class="level4" aria-labelledby="ファイル名"><h4 id="ファイル名">ファイル名</h4><p>ログをファイルに書き込む。</p></section><section class="level4" aria-labelledby="-ファイル名"><h4 id="-ファイル名">-ファイル名</h4><p>ログをファイルに書き込む際にバッファリングする。書き込み性能が向上するが、書き込まれていないデータがある時にシステム障害が発生するとログが失われる。</p></section><section class="level4" aria-labelledby="プログラム"><h4 id="プログラム">\プログラム</h4><p>ログメッセージをプログラムに引き渡す。</p></section><section class="level4"><h4 id="">*</h4><p>すべてのユーザのコンソールにメッセージを表示する。</p></section><section class="level4" aria-labelledby="ホスト名あるいはipアドレス"><h4 id="ホスト名あるいはipアドレス">@ホスト名（あるいはIPアドレス）</h4><p>UDPでsyslogサーバにログメッセージを送信する。</p></section><section class="level4" aria-labelledby="ホスト名あるいはipアドレス-1"><h4 id="ホスト名あるいはipアドレス-1">@@ホスト名（あるいはIPアドレス）</h4><p>TCPでsyslogサーバにログメッセージを送信する。</p></section></section><section class="level3" aria-labelledby="syslogサーバのデフォルト設定を確認する"><h3 id="syslogサーバのデフォルト設定を確認する">syslogサーバのデフォルト設定を確認する</h3><p>設定ファイル/etc/rsyslog.confに既に設定されている内容を確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">authpriv.* /var/log/secure</span></code></pre><p>この設定は、ファシリティがauthpriv（認証関係）、プライオリティが*（全てのプライオリティ）のログメッセージは/var/log/secureに出力するように指定しています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">*.info;mail.none;authpriv.none;cron.none  /var/log/messages</span></code></pre><p>この設定は、すべてのファシリティのinfoプライオリティ以上のログをすべて/var/log/messagesに出力するようにしています。ただし、mail、authpriv、cronの3つのファシリティにはnoneプライオリティが指定されているため、対象からは除外されています。</p><p>除外された各ファシリティの出力は、以下のように別途指定されています。</p><p>mailファシリティのログは、メモリ上にある程度バッファリングした上でログファイルに書き込むように「-（ハイフン）」を指定しています。メールサーバは一度に大量のログを書き込むことが多いからです。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">authpriv.*      /var/log/secure
mail.*       -/var/log/maillog
cron.*       /var/log/cron</span></code></pre></section><section class="level3" aria-labelledby="カーネルログのsyslog出力設定"><h3 id="カーネルログのsyslog出力設定">カーネルログのsyslog出力設定</h3><p>デフォルトの設定ではコメントアウトされて無効になっているカーネルからのログ出力の設定を有効にします。カーネルのログは、たとえばiptablesのようなカーネルの機能がログを出力します。</p><p>iptablesの設定ファイル/etc/sysconfig/iptablesを編集し、ポート番号22番の許可（ACCEPT）と、その他の全てを拒否（REJECT）するルールの間に、ログを取得するルールを追加します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Firewall configuration written by system-config-firewall</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Manual customization of this <span class="token function">file</span> is not recommended.</span></span>
<span class="token output">*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
※-A INPUT -j LOG --log-level debug --log-prefix '[iptables_test]:' ←新規に追加
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT</span></code></pre><p>iptablesサービスをreloadして、新しい設定を読み込ませます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> iptables reload</span></span>
<span class="token output">iptables: Trying to reload firewall rules:                 [  OK  ]</span></code></pre><p>/etc/rsyslog.confを編集し、ファシリティがkern、プライオリティが全てのメッセージを/var/log/kern.logに出力する設定を追加します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/rsyslog.conf</span></span>

<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Log all kernel messages to the console.</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Logging much <span class="token keyword">else</span> clutters up the screen.</span></span>
<span class="token output">#kern.*                                                 /dev/console
※kern.*                                                 /var/log/kern.log ←新規に追加</span></code></pre><p>rsyslogサービスを再起動して、新しい設定を読み込ませます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> rsyslog restart</span></span>
<span class="token output">システムロガーを停止中:                                    [  OK  ]
システムロガーを起動中:                                    [  OK  ]</span></code></pre><p>外部のホストから設定を行ったホストに対して、iptablesで許可されていないポート番号80番にWebブラウザ等でアクセスします。</p><p>/var/log/kern.logにポート番号80番に対する通信を拒否した旨のログが出力されます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">tail</span> /var/log/kern.log</span></span>
<span class="token output">Dec 25 14:54:16 server kernel: imklog 5.8.10, log source = /proc/kmsg started.
Dec 25 14:54:50 server kernel: ※'[iptables_test]:'※IN=eth0 OUT= MAC=00:1c:42:65:af:c4:00:1c:42:00:00:08:08:00 SRC=192.168.0.2 DST=192.168.0.10 LEN=64 TOS=0x00 PREC=0x00 TTL=64 ID=24955 DF PROTO=TCP SPT=57191 ※DPT=80※ WINDOW=65535 RES=0x00 SYN URGP=0</span></code></pre></section><section class="level3" aria-labelledby="リモートホストのログをudpで受け取る"><h3 id="リモートホストのログをudpで受け取る">リモートホストのログをUDPで受け取る</h3><p>syslogサーバとしてリモートホストのログを受け取るための設定を行います。syslogのメッセージの送受信は、通常UDPで行われます。</p><p>設定ファイル/etc/rsyslog.conf内にある以下の2行から、行頭のコメントアウトを削除して設定を有効にします。</p><p><span class="math inline" data-math-typeset="true">\(ModLoadは、UDP用のプロトコルモジュールのロードを設定しています。\)</span>UDPServerRunは、UDPでログメッセージを受け取るポート番号を指定しています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">[root@server ~]## vi /etc/rsyslog.conf

（略）
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Provides UDP syslog reception</span></span>
<span class="token output">$ModLoad imudp ※←行頭の#を削除
$UDPServerRun 514 ※←行頭の#を削除</span></code></pre><p>rsyslogサービスを再起動します。rsyslogdがUDPのポート番号514番で待ち受けるようになります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> rsyslog restart</span></span>
<span class="token output">システムロガーを停止中:                                    [  OK  ]
システムロガーを起動中:                                    [  OK  ]
</span><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">lsof</span> -i:514</span></span>
<span class="token output">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rsyslogd 9282 root    3u  IPv4 134339      0t0  UDP *:syslog
rsyslogd 9282 root    4u  IPv6 134340      0t0  UDP *:syslog</span></code></pre><p>設定後、iptablesの設定を変更し、UDPのポート番号514番へのパケットを許可するように設定を変更する必要があります。設定については後述します。</p></section><section class="level3" aria-labelledby="リモートホストのログをtcpで受け取る"><h3 id="リモートホストのログをtcpで受け取る">リモートホストのログをTCPで受け取る</h3><p>ログメッセージの送受信にTCPを使用することにより、UDPで発生していたログの取りこぼしを防ぐことができます。UDPはセッションレスなプロトコルのため、送受信に失敗した時に再送信する仕組みが無いためです。</p><p>ただし、TCPはプロトコルの性質上UDPよりも処理が重くなってしまうため、大量のログが送信されてくる環境では逆にボトルネックになってしまい、syslogサーバ側が高負荷で処理が滞ってしまう可能性があります。</p><p>そのため、TCPを使ったログメッセージの送受信は、ログの量がそれほど多くなくログ記録の信頼性が必要な場合に設定します。もし、大量のログが送信されてくる場合には、syslogサーバを複数用意するか、UDPを使う必要があります。</p><p>設定ファイル/etc/rsyslog.conf内にある以下の2行から、行頭のコメントアウトを削除して設定を有効にします。</p><p><span class="math inline" data-math-typeset="true">\(ModLoadは、TCP用のプロトコルモジュールのロードを設定しています。\)</span>InputTCPServerRunは、TCPでログメッセージを受け取るポート番号を指定しています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/rsyslog.conf</span></span>

<span class="token output">（略）
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Provides TCP syslog reception</span></span>
<span class="token output">$ModLoad imtcp ※←行頭の#を削除
$InputTCPServerRun 514 ※←行頭の#を削除</span></code></pre><p>rsyslogサービスを再起動します。rsyslogdがTCPのポート番号514番で待ち受けるようになります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> rsyslog restart</span></span>
<span class="token output">システムロガーを停止中:                                    [  OK  ]
システムロガーを起動中:                                    [  OK  ]
</span><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">lsof</span> -i:514</span></span>
<span class="token output">COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
rsyslogd 24138 root    1u  IPv4 107209      0t0  TCP *:shell (LISTEN)
rsyslogd 24138 root    3u  IPv4 107202      0t0  UDP *:syslog
rsyslogd 24138 root    4u  IPv6 107203      0t0  UDP *:syslog
rsyslogd 24138 root    8u  IPv6 107210      0t0  TCP *:shell (LISTEN)</span></code></pre><p>ポートがshellと表示されているのは、ポート番号の設定ファイル/etc/servicesで定義されているためです。動作に影響はありません。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">grep</span> <span class="token number">514</span> /etc/services</span></span>
<span class="token output">shell           514/tcp         cmd             # no passwords used
syslog          514/udp
（略）</span></code></pre><p>設定後、iptablesの設定を変更し、TCPのポート番号514番へのパケットを許可するように設定を変更する必要があります。</p></section><section class="level3" aria-labelledby="syslogサーバのiptablesの設定"><h3 id="syslogサーバのiptablesの設定">syslogサーバのiptablesの設定</h3><p>syslogサーバのiptablesの設定を変更し、TCPおよびUDPのポート番号514番の接続を許可しておきます。あるいは、iptablesサービスを停止しておきます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> iptables stop</span></span>
<span class="token output">iptables: チェインをポリシー ACCEPT へ設定中filter         [  OK  ]
iptables: ファイアウォールルールを消去中:                  [  OK  ]
iptables: モジュールを取り外し中:                          [  OK  ]</span></code></pre><p>/etc/sysconfig/iptablesへのiptablesのルールを追加するには、以下のようになります。パケットをRejectするルールの前に、ルール設定を追加します。ルール設定を追加したらiptablesサービスをreloadしておきます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/sysconfig/iptables</span></span>
<span class="token output">（略）
※-A INPUT -m state --state NEW -m udp -p udp --dport 514 -j ACCEPT ←新規に追加
※-A INPUT -m state --state NEW -m tcp -p tcp --dport 514 -j ACCEPT ←新規に追加
-A INPUT -j REJECT --reject-with icmp-host-prohibited</span></code></pre></section><section class="level3" aria-labelledby="syslogクライアントの設定"><h3 id="syslogクライアントの設定">syslogクライアントの設定</h3><p>ネットワークで接続されたsyslogサーバに対してログメッセージを送信するsyslogクライアントを設定します。</p><p>syslogクライアント側のホストでもrsyslogを設定し、アクションの設定でネットワーク上のsyslogサーバを指定します。</p><p>syslogクライアントの設定ファイル/etc/rsyslog.confを修正します。</p><p>authprivファシリティに関するすべてのログをsyslogサーバに送信するように設定を追加します。@送信先と指定することでUDPを使用した送信を指定できます。</p><p>また、mailファシリティに関するすべてのログをsyslogサーバに送信するように設定を追加します。@@送信先と指定することでTCPを使用した送信を指定できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/rsyslog.conf</span></span>

<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">The authpriv <span class="token function">file</span> has restricted access.</span></span>
<span class="token output">authpriv.*                                              /var/log/secure
※authpriv.*                                              @192.168.0.10 ←新規に追加

</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">Log all the mail messages <span class="token keyword">in</span> one place.</span></span>
<span class="token output">mail.*                                                  -/var/log/maillog
※mail.*                                                  @@192.168.0.10 ←新規に追加```

syslogクライアントのrsyslogサービスを再起動します。

```shell-session
</span><span class="token command"><span class="token info punctuation"><span class="token user">[root@client ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> rsyslog restart</span></span>
<span class="token output">システムロガーを停止中:                                    [  OK  ]
システムロガーを起動中:                                    [  OK  ]</span></code></pre><section class="level4" aria-labelledby="udpでログを送信"><h4 id="udpでログを送信">UDPでログを送信</h4><p>syslogクライアントでloggerコマンドを実行して、authpriv.debugプライオリティでログを出力します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@client ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash">logger -p authpriv.debug <span class="token string">"This is auth log over UDP"</span></span></span></code></pre><p>syslogサーバ上の/var/log/secureにログが出力されることを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">tail</span> -f /var/log/secure</span></span>
<span class="token output">（略）
Dec 25 17:16:50 client root: This is auth log over UDP</span></code></pre></section><section class="level4" aria-labelledby="tcpでログを送信"><h4 id="tcpでログを送信">TCPでログを送信</h4><p>syslogクライアントでloggerコマンドを実行して、mail.debugプライオリティでログを出力します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@client ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash">logger -p mail.debug <span class="token string">"This is mail log over TCP"</span></span></span></code></pre><p>syslogサーバ上の/var/log/maillogにログが出力されることを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">tail</span> /var/log/secure</span></span>
<span class="token output">（略）
Dec 25 17:18:03 client root: This is mail log over TCP</span></code></pre></section></section><section class="level3" aria-labelledby="logrotateによるログローテーション"><h3 id="logrotateによるログローテーション">logrotateによるログローテーション</h3><p>ログファイルは常に追記されていくため、ファイルサイズが次第に肥大化してディスク容量を圧迫し、後でログを確認する際に必要なログを見つけにくくなります。これらの問題を回避するため、ログを一定期間でローテーションするlogrotateが使われています。</p><p>logrotateは、cronから1日1回、/etc/cron.daily/logrotateスクリプトによって起動されます。/etc/logrotate.confがlogrotateの設定ファイルとなっており、ログファイルをローテーションするタイミングや、ログファイルを何世代まで残すかなどの設定が記述されています。サービス毎の詳細な設定は、/etc/logrotate.dディレクトリに格納されています。</p><p>logrotateの設定で使用できるディレクティブは以下のとおりです。</p><section class="level4" aria-labelledby="create-モード-所有ユーザ-所有グループ"><h4 id="create-モード-所有ユーザ-所有グループ">create [モード] [所有ユーザ] [所有グループ]</h4><p>ローテーションを行った後、代わりに空の新規ログファイルを作成します。属性も指定できます。モードは0755のような数値書式。指定しない属性については元のファイルの属性が引き継がれます。</p></section><section class="level4" aria-labelledby="nocreate"><h4 id="nocreate">nocreate</h4><p>createをグローバルに設定した場合に、個別にcreateを無効にしたい際に使用します。</p></section><section class="level4" aria-labelledby="copynocopy"><h4 id="copynocopy">copy/nocopy</h4><p>元のログファイルはそのままにして、コピーを保存します。</p></section><section class="level4" aria-labelledby="copytruncatenocopytruncate"><h4 id="copytruncatenocopytruncate">copytruncate/nocopytruncate</h4><p>copyの動作を行った後、元のログファイルの内容を消去します。見かけ的にはcreateと同じ結果となります。これはログファイルをリロードする方法が無いプログラムへの対処法のひとつです。たとえばOracle 10g R1/R2のalertログに対しては、この方法を行わないと以前のログファイル（例えばalert_xx.log.1）にログが書き込み続けられます。</p></section><section class="level4" aria-labelledby="rotate-世代数"><h4 id="rotate-世代数">rotate 世代数</h4><p>世代ローテーションの世代数を指定します。たとえば元のログファイルがa.logの場合、numに2を指定すると、a.log→a.log.1→a.log.2→廃棄となります。0の場合、a.log→廃棄となります。</p></section><section class="level4" aria-labelledby="start-数値"><h4 id="start-数値">start 数値</h4><p>最初のローテーションファイルの末尾に付加する値を指定します。デフォルトは1です。たとえばnumに5を指定すると、a.log→a.log.5→a.log.6となります。</p></section><section class="level4" aria-labelledby="extension-拡張子"><h4 id="extension-拡張子">extension 拡張子</h4><p>ローテーションした旧ログファイルに付ける拡張子を指定します。指定には区切りのドットも必要です。たとえば拡張子に「.bak」と指定すると、some.logの初代ローテーションログはsome.log.1.bakとなります。圧縮も行う場合、圧縮による拡張子はさらにその後ろに付きます。</p></section><section class="level4" aria-labelledby="compressnocompress"><h4 id="compressnocompress">compress/nocompress</h4><p>ローテーションした後の旧ファイルに圧縮を掛けます。デフォルトはnocompress（非圧縮）です。</p></section><section class="level4" aria-labelledby="compresscmd-コマンド"><h4 id="compresscmd-コマンド">compresscmd コマンド</h4><p>ログファイルの圧縮に使用するプログラムを指定します。デフォルトはgzipです。</p></section><section class="level4" aria-labelledby="uncompresscmd-コマンド"><h4 id="uncompresscmd-コマンド">uncompresscmd コマンド</h4><p>ログファイルの解凍に使用するプログラムを指定します。デフォルトはgunzipです。</p></section><section class="level4" aria-labelledby="compressoptions-オプション"><h4 id="compressoptions-オプション">compressoptions オプション</h4><p>圧縮プログラムへ渡すオプションを指定します。デフォルトはgzipに渡す「-9」（圧縮率最大）です。「-9 -s」のようにスペース入りで複数のオプションを指定することはできません。</p></section><section class="level4" aria-labelledby="compressext-拡張子"><h4 id="compressext-拡張子">compressext 拡張子</h4><p>圧縮後のファイルに付ける拡張子（ドットも必要）を指定します。デフォルトでは、使用する圧縮コマンドに応じたものが付けられます。</p></section><section class="level4" aria-labelledby="delaycompressnodelaycompress"><h4 id="delaycompressnodelaycompress">delaycompress/nodelaycompress</h4><p>圧縮処理を次のローテーションまで遅らせる、あるいは遅らせません。</p></section><section class="level4" aria-labelledby="olddir-ディレクトリnoolddir"><h4 id="olddir-ディレクトリnoolddir">olddir ディレクトリ/noolddir</h4><p>ローテーションした旧ログをディレクトリに移動します。移動先は元と同じデバイス上で指定します。元のログに対する相対指定も有効です。</p></section><section class="level4" aria-labelledby="mail-addressnomail"><h4 id="mail-addressnomail">mail address/nomail</h4><p>旧ログファイルをaddressに送信します。どの段階のログを送るかはmaillastなどのオプションで決まります。</p></section><section class="level4" aria-labelledby="maillast"><h4 id="maillast">maillast</h4><p>世代が終わって破棄されるログをメールします。</p></section><section class="level4" aria-labelledby="mailfirst"><h4 id="mailfirst">mailfirst</h4><p>初代ローテーションログをメールします。</p></section><section class="level4" aria-labelledby="dailyweeklymonthly"><h4 id="dailyweeklymonthly">daily/weekly/monthly</h4><p>ログローテーションを日毎/週毎/月毎に行います。デフォルトはdaily。たとえばweeklyなら、毎日実行したとしても、週に1回だけローテーションが行われます。</p></section><section class="level4" aria-labelledby="size-サイズkm"><h4 id="size-サイズkm">size サイズ[K/M]</h4><p>ログのサイズがサイズバイトを超えていればローテーションを行います。この条件はdaily,weeklyなどの条件より優先されます。キロバイト（K）、メガバイト（M）での指定もできます。</p></section><section class="level4" aria-labelledby="ifemptynotifempty"><h4 id="ifemptynotifempty">ifempty/notifempty</h4><p>元のログファイルが空でもローテーションを行う、あるいは行いません。</p></section><section class="level4" aria-labelledby="missingoknomissingok"><h4 id="missingoknomissingok">missingok/nomissingok</h4><p>指定のログファイルが存在しなかったとしてもエラーを出さずに処理を続行する、あるいはエラーを出力します。</p></section><section class="level4" aria-labelledby="firstaction"><h4 id="firstaction">firstaction</h4><p>ローテーションを行う前にスクリプトを実行します。preroteteよりも前に実行される個別定義内でのみ指定可能です。</p></section><section class="level4" aria-labelledby="prerotate"><h4 id="prerotate">prerotate</h4><p>ローテーションを行う前にスクリプトを実行します。firstactionの後に実行されます。個別定義内でのみ指定できます。</p></section><section class="level4" aria-labelledby="postrotate"><h4 id="postrotate">postrotate</h4><p>ローテーションが行われた後にスクリプトを実行します。lastactionより前に実行されます。個別定義内でのみ指定できます。</p></section><section class="level4" aria-labelledby="lastaction"><h4 id="lastaction">lastaction</h4><p>ローテーションが行われた後（よりも後）にスクリプトを実行します。postrotateの後に実行されます。個別定義内でのみ指定できます。</p></section><section class="level4" aria-labelledby="sharedscripts"><h4 id="sharedscripts">sharedscripts</h4><p>ローテーションするログが複数あった場合に、prerotate、postrotateのスクリプトを一度だけ実行します。</p></section><section class="level4" aria-labelledby="nosharedscripts"><h4 id="nosharedscripts">nosharedscripts</h4><p>ローテーションするログが複数あった場合に、prerotate、postrotateのスクリプトを各ログファイル毎に実行します。</p></section><section class="level4" aria-labelledby="include-ファイルディレクトリ"><h4 id="include-ファイルディレクトリ">include ファイル（ディレクトリ）</h4><p>includeの記述のある位置に別の設定ファイルを読み込みます。ディレクトリを指定した場合、そのディレクトリ内から、ディレクトリおよび名前付きパイプ以外の通常ファイルがアルファベット順に読み込まれます。</p></section><section class="level4" aria-labelledby="tabooext--拡張子拡張子"><h4 id="tabooext--拡張子拡張子">tabooext [+] 拡張子[,拡張子,...]</h4><p>includeでディレクトリを指定した場合に読み込むファイルから除外するファイルの拡張子を指定します。デフォルトで「.rpmorig」「.rpmsave」「,v」「.swp」「.rpmnew」「~」「.cfsaved」「.rhn-cfg-tmp-*」が指定されています。+を指定するとデフォルト指定に対して追加で拡張子を指定できます。+を指定しないとデフォルト指定を破棄して新規に拡張子を指定します。</p></section></section><section class="level3" aria-labelledby="ログローテート設定ファイルの確認"><h3 id="ログローテート設定ファイルの確認">ログローテート設定ファイルの確認</h3><p>/etc/logrotate.d/httpdを参考に、ローテートの設定を確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">cat</span> /etc/logrotate.d/httpd</span></span>
<span class="token output">/var/log/httpd/*log {
    missingok
    notifempty
    sharedscripts
    delaycompress
    postrotate
        /sbin/service httpd reload > /dev/null 2>/dev/null || true
    endscript
}</span></code></pre><p>この例では、以下の通りログローテーションの処理が行われます。</p><p>対象となるログファイルは/var/log/httpdディレクトリ内の、ファイル名がlogで終わるすべてのログファイルです。デフォルトではaccess_log、error_logというファイル名のログファイルが作成されています。</p><ul>
<li>1行目のmissingokでログファイルが実在しなかったとしてもエラーを出さずに処理を続行します。</li>
<li>2行目のnotifemptyで元のログファイルが空ならばローテーションしません。</li>
<li>3行目のsharedscriptsでprerotate,postrotate のスクリプトを一度だけ実行します。</li>
<li>4行目のdelaycompressで圧縮処理を次のローテーションまで遅らせます。</li>
<li>5行目の"postrotate"から"endscript"までが、ローテーションが行われた後に実行されるスクリプトです。serviceコマンドを実行してhttpdサービスをreloadすることで、新しいログファイルが生成されます。</li>
</ul></section></section><section class="level2" aria-labelledby="ネットワークツールを使ったトラブルシューティング"><h2 id="ネットワークツールを使ったトラブルシューティング">ネットワークツールを使ったトラブルシューティング</h2><p>サーバに接続できないなどネットワークに起因する問題が発生した場合、基本的な原因の調査を行うためのツールとして、以下のようなネットワークツールを使用します。</p><ul>
<li>ping</li>
<li>traceroute</li>
<li>netstat</li>
<li>tcpdump</li>
<li>Wireshark</li>
</ul><p>これらのツールを使用した、トラブルシューティングについて解説します。一般的には、外部からサービスへの接続ができなくなった場合には、以下のような手順で原因の調査を行います。</p><ol>
<li>ログの確認</li>
<li>pingコマンドによるIP通信の確認</li>
<li>telnetコマンドによるTCP通信の確認</li>
<li>netstatコマンドによるポートの状況の確認</li>
<li>通信内容の確認</li>
</ol><section class="level3" aria-labelledby="pingコマンドによるip通信の確認"><h3 id="pingコマンドによるip通信の確認">pingコマンドによるIP通信の確認</h3><p>pingコマンドを使って、サーバに対する通信が行えるかどうかを確認します。pingコマンドはICMPを使った通信でIP通信が可能か確認できます。サーバに対するpingに応答が無い場合、以下のような問題が考えられます。</p><section class="level4" aria-labelledby="サーバ自身の問題"><h4 id="サーバ自身の問題">サーバ自身の問題</h4><p>IPアドレスやデフォルトゲートウェイが適切に設定されていなかったり、iptablesなどのパケットフィルタリングでICMPを通さない設定になっていることが考えられます。<br>
サーバのネットワーク設定を再度確認してみます。また、サーバ側から他のホストへpingコマンドを実行して、応答があるか確認してみます。</p></section><section class="level4" aria-labelledby="ネットワーク経路の問題"><h4 id="ネットワーク経路の問題">ネットワーク経路の問題</h4><p>ネットワーク通信経路上にあるケーブルやスイッチ、ルーター、ファイアーウォールやロードバランサーなどのネットワーク機器に問題が無いかを確認します。<br>
ルーティングに問題があるかを確認するためにはtracerouteコマンドを使用しますが、tracerouteコマンドはICMPを使用しているため、途中のルーターでICMPを通さない場合、すべての経路が確認できないことがあります。</p></section></section><section class="level3" aria-labelledby="telnetコマンドによるtcp通信の確認"><h3 id="telnetコマンドによるtcp通信の確認">telnetコマンドによるTCP通信の確認</h3><p>telnetコマンドは2番目の引数にポート番号を指定して、サーバのサービスに接続することができるので、TCP通信が可能か確認できます。</p><pre class="language-text"><code class="language-text">telnet 接続先IPアドレス ポート番号</code></pre><p>ただし、ディストリビューションによってはtelnetコマンドがインストールされていないので、インストールする必要があります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">yum <span class="token function">install</span> telnet</span></span></code></pre><p>サービスに接続できない場合には、以下のような問題が考えられます。</p><section class="level4" aria-labelledby="ネットワーク経路の問題-1"><h4 id="ネットワーク経路の問題-1">ネットワーク経路の問題</h4><p>iptablesやネットワーク経路上のファイアーウォールなどで、指定されたポートへの通信が許可されていない。<br>
iptablesやファイアーウォールのポート許可設定を確認します。</p></section><section class="level4" aria-labelledby="サーバ自身の問題-1"><h4 id="サーバ自身の問題-1">サーバ自身の問題</h4><p>サービスが停止しており、指定されたポートをListenしていない。あるいは、ローカルループバックアドレス（127.0.0.1）のみListenしており、接続先に指定したIPアドレスにポートがバインドされていない。<br>
netstatコマンドやlsofコマンドなどを使用して、ポートの状態を確認します。</p></section></section><section class="level3" aria-labelledby="netstatでのポートの状況の確認"><h3 id="netstatでのポートの状況の確認">netstatでのポートの状況の確認</h3><p>netstatコマンドを使って、サービスプロセスとポート番号、さらにIPアドレスとのバインドの状況が確認できます。</p><p>netstatコマンドに-pオプションを指定して実行します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">netstat</span> -anp <span class="token operator">|</span> <span class="token function">grep</span> sshd</span></span>
<span class="token output">tcp        0      0 0.0.0.0:22     0.0.0.0:*  LISTEN   1493/sshd</span></code></pre><p>この結果から、以下のことが分かります。</p><ul>
<li>sshdのプロセスIDが1493であること</li>
<li>TCPポート番号22番でLISTENしていること</li>
<li>ポート番号22番がサーバのすべてのIPアドレス（0.0.0.0:22）にバインドされていること</li>
<li>送信元制限を行っていないこと（0.0.0.0:*）</li>
</ul></section><section class="level3" aria-labelledby="パケットキャプチャによる通信内容の確認"><h3 id="パケットキャプチャによる通信内容の確認">パケットキャプチャによる通信内容の確認</h3><p>サーバとの接続が行えており、ログにも手がかりとなるエラーが無いが、サービスが正しく動作しないような場合には、通信パケットをキャプチャして、通信内容を確認します。パケットをキャプチャすることで、サーバとクライアントの間でどのような通信が行われているかを確認できます。<br>
パケットキャプチャのツールとしては、シンプルに機能するtcpdumpコマンドと、GUIで操作できるWiresharkなどがあります。</p></section><section class="level3" aria-labelledby="tcpdumpコマンドを使ったパケットキャプチャ"><h3 id="tcpdumpコマンドを使ったパケットキャプチャ">tcpdumpコマンドを使ったパケットキャプチャ</h3><p>tcpdumpコマンドは、送受信しているパケットをキャプチャして、その情報を標準出力に出力するコマンドです。<br>
tcpdumpコマンドはデフォルトでは全てのパケットの情報を出力するので、オプションで出力結果をフィルタリングして、必要な情報を得られるようにします。</p><p>例として、-iオプションでネットワークインターフェースを指定して、eth0を通じて入ってくる通信のパケットを取得してみます。</p><p>サーバ上でtcpdumpコマンドを実行します。結果をリダイレクトして、tcpdump.outファイルに記録します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">tcpdump -i eth0 <span class="token operator">></span> tcpdump.out</span></span>
<span class="token output">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes</span></code></pre><p>クライアントからSSHでサーバにログインし、ログアウトします。</p><p>サーバでCtrl+Cキーを入力して、tcpdumpコマンドを終了します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
※^C※216 packets captured ※←Ctrl+Cキーを入力
216 packets received by filter
0 packets dropped by kernel</span></code></pre><p>作成されたtcpdump.outファイルの内容を確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">grep</span> <span class="token function">ssh</span> tcpdump.out</span></span>
<span class="token output">13:17:06.041096 IP client.example.com.43880 > server.example.com.ssh: ※Flags [S]※, seq 4050960604, win 14600, options [mss 1460,sackOK,TS val 13231 ecr 0,nop,wscale 6], length 0
13:17:06.041125 IP server.example.com.ssh > client.example.com.43880: ※Flags [S.]※, seq 3335753529, ※ack 4050960605※, win 14480, options [mss 1460,sackOK,TS val 22019990 ecr 13231,nop,wscale 6], length 0
13:17:06.041240 IP client.example.com.43880 > server.example.com.ssh: ※Flags [.]※, ※ack 1※, win 229, options [nop,nop,TS val 13231 ecr 22019990], length 0</span></code></pre><p>左から時間（マイクロ秒単位)、送信元IPアドレス.ポート番号、通信の向きの矢印、宛先ホスト.ポート番号、フラグ（SYN)、シーケンス、ウィンドウ、オプション、最大セグメントサイズとなっています。</p><section class="level4" aria-labelledby="1行目"><h4 id="1行目">1行目</h4><p>クライアントのポート43880からサーバのポート22（ssh）に向けてSYNフラグのTCPパケットと送信して接続の要求</p></section><section class="level4" aria-labelledby="2行目"><h4 id="2行目">2行目</h4><p>1行目のパケットに対して、SYN+ACKフラグのTCPパケットを送信</p></section><section class="level4" aria-labelledby="3行目"><h4 id="3行目">3行目</h4><p>ACKフラグのTCPパケットを送信して、TCPのスリーウェイハンドシェイクが完了</p><p>このように、サーバとクライアントの間の通信を確認できます。</p></section></section><section class="level3" aria-labelledby="wiresharkを使った確認"><h3 id="wiresharkを使った確認">Wiresharkを使った確認</h3><p>tcpdumpの出力ファイルは少量のパケットを見る場合には充分ですが、大量のパケットを確認するには可読性が低いのが難点です。</p><p>GUIを持つパケットキャプチャリングソフトであるWiresharkを使えば、パケットキャプチャリングを行ったパケットの中身を見たり、フィルタリング機能で必要なパケットのみに絞り込んでパケットを確認することができます。</p><p>Wiresharkをインストールします。GUI版をインストールするため、wireshark-gnomeパッケージをインストールします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">yum <span class="token function">install</span> wireshark-gnome</span></span></code></pre><ol>
<li>Wiresharkを起動します。<br>
CentOSにGUIでログインし、端末からwiresharkコマンドを実行するか、「アプリケーション」メニュー→「インターネット」→「Wireshark Network Analyzer」を起動します。</li>
</ol><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">wireshark <span class="token operator">&#x26;</span></span></span></code></pre><p>＃2</p><ol start="2">
<li>キャプチャを行うデバイスを選びます。</li>
</ol><figure><img src="wireshark1.png" alt="「Capture」メニュー→「Interfaces」を選択します"><figcaption aria-hidden="true">「Capture」メニュー→「Interfaces」を選択します</figcaption></figure><p>「Capture」メニュー→「Interfaces」を選択し、パケットキャプチャを行いたいデバイスを選びます。</p><p>＃3</p><ol start="3">
<li>パケットキャプチャを開始します。</li>
</ol><figure><img src="wireshark2.png" alt="eth0を選択します"><figcaption aria-hidden="true">eth0を選択します</figcaption></figure><p>外部との通信をパケットキャプチャするためにeth0を選びます。「Start」ボタンをクリックして、パケットキャプチャを開始します。</p><p>＃4</p><ol start="4">
<li>Webサーバにアクセスします。<br>
サーバと通信を行ってパケットキャプチャを行います。クライアントでWebブラウザを起動し、サーバのWebサーバにアクセスします。</li>
</ol><p>＃5</p><ol start="5">
<li>パケットキャプチャを停止します。<br>
「Capture」メニュー→「Stop」を選択し、パケットキャプチャを停止します。</li>
</ol><p>＃6</p><ol start="6">
<li>結果の絞り込みを行います。</li>
</ol><figure><img src="wireshark3.png" alt="httpで絞り込みを行います"><figcaption aria-hidden="true">httpで絞り込みを行います</figcaption></figure><p>「Filter:」のテキストボックスに「http」と入力して、Enterキーを押して絞り込みます。<br>
参照したいパケットを選択し、ウインドウ真ん中の詳細情報で「Hypertext Transfer Protocol」をダブルクリックして、HTTP通信の内容を確認します。</p></section></section><section class="level2" aria-labelledby="ファイルシステム障害の修復"><h2 id="ファイルシステム障害の修復">ファイルシステム障害の修復</h2><p>ファイルシステム障害が発生してOSが正常に起動しなくなった場合、起動ディスクである程度までシステム起動が可能ならばシングルユーザーモードで起動したり、起動ディスクでシステムを起動できない場合にはインストール用のメディアをレスキューモードで起動することで、ファイルシステムを修復できます。</p><section class="level3" aria-labelledby="シングルユーザモードでの起動"><h3 id="シングルユーザモードでの起動">シングルユーザモードでの起動</h3><p>シングルユーザモードでLinuxを起動すると、ランレベル1で起動するため各種サービスの起動が行われず、rootユーザだけがシステムにアクセスできる状態で起動します。<br>
たとえば、サービスの設定を間違えたためランレベル3やランレベル5で起動するとシステムに不具合が発生する場合には、シングルユーザーモードで起動して設定を修正します。</p><p>起動時に表示できるGRUBメニューで起動パラメーターを編集してシングルモードで起動します。</p><ol>
<li>起動時のデフォルトでは、設定された秒数（デフォルトでは5秒）が過ぎると自動的に起動しますが、何かキーを入力するとGRUBメニューが表示されます。</li>
<li>キーボードのeキーを押して起動パラメーターの編集モードに入り、kernel行を選択してさらにeキーを押し、末尾に「single」（あるいは1）とパラメーターを追記します。</li>
<li>Enterキーを押して編集モード画面に戻ります。</li>
<li>bキーを押してシングルユーザモード起動します。</li>
</ol><figure><img src="singleuserboot.png" alt="カーネルパラメータでシングルユーザーモード起動を設定します"><figcaption aria-hidden="true">カーネルパラメータでシングルユーザーモード起動を設定します</figcaption></figure><p>＃5</p><ol start="5">
<li>シングルユーザモードで起動すると、パスワード無しでrootユーザとしてログインしている状態となります。必要に応じてfsckコマンドでファイルシステムを修復したり、設定ファイルを修正するなどしてトラブルの解決を行います。</li>
<li>シェルからexitすると、デフォルトのランレベルに移行します。</li>
</ol></section><section class="level3" aria-labelledby="インストールdvdメディアからレスキューモードで起動"><h3 id="インストールdvdメディアからレスキューモードで起動">インストールDVDメディアからレスキューモードで起動</h3><p>起動ディスクのファイルシステムに障害が発生して、正常にOSが起動できなくなってしまった場合には、インストールDVDメディアからレスキューモードで起動し、ファイルシステムの修復を行います。</p><ol>
<li>
<p>CentOSのインストールDVDメディアでシステムを起動します。BIOSで起動デバイスの順番を変更するなどして、DVDドライブから起動するようにします。</p>
</li>
<li>
<p>起動メニューから「Rescue installed system」を選択します。</p>
</li>
</ol><figure><img src="rescue1.png" alt="起動メニュー"><figcaption aria-hidden="true">起動メニュー</figcaption></figure><p>＃3</p><ol>
<li>Language、キーボードレイアウト、修復作業中にネットワークを使用するかを選択します。</li>
</ol><p><img src="rescue2.png" alt="Languageを選択します"><br>
<img src="rescue3.png" alt="キーボードレイアウトを選択します"><br>
<img src="rescue4.png" alt="ネットワーク使用の有無を選択します"></p><p>＃4</p><ol>
<li>ハードディスクを検索し、/mnt/sysimage以下にマウントする旨の説明が表示されます。「Read-Only」を選ぶと、ハードディスクが読み取り専用でマウントされます。修復を行うため、「Continue」を選択します。</li>
</ol><figure><img src="rescue5.png" alt="Continueを選択します"><figcaption aria-hidden="true">Continueを選択します</figcaption></figure><p>＃5</p><ol>
<li>ハードディスクを検索し、/mnt/sysimage以下にマウントできた旨が表示されます。</li>
</ol><figure><img src="rescue6.png" alt="/mnt/sysimageにハードディスクがマウントされました"><figcaption aria-hidden="true">/mnt/sysimageにハードディスクがマウントされました</figcaption></figure><p>＃6</p><ol>
<li>実行する作業を選択します。「shell」を選ぶとシェルが起動します。「fakd」を選ぶとFirst Aid Kitが実行されてシステムの検査が行えます。「reboot」を選ぶとシステムを再起動します。「shell」を選択します。</li>
</ol><figure><img src="rescue7.png" alt="shellを選択します"><figcaption aria-hidden="true">shellを選択します</figcaption></figure><p>＃7</p><ol>
<li>bashが起動します。/mnt/sysimage以下に、ハードディスクのルートパーティションがマウントされていることを確認します。</li>
</ol><figure><img src="rescue8.png" alt="シェルが起動します"><figcaption aria-hidden="true">シェルが起動します</figcaption></figure><p>＃8</p><ol>
<li>
<p>fsckコマンドなどを利用して、ファイルシステムの修復作業を行います。修復作業が終了したら、exitでシェルを終了します。作業の選択画面に戻ります。</p>
</li>
<li>
<p>「reboot」を選択して、システムを再起動します。インストールDVDメディアはDVDドライブから取り出しておきます。</p>
</li>
</ol><figure><img src="rescue9.png" alt="rebootを選択して再起動します"><figcaption aria-hidden="true">rebootを選択して再起動します</figcaption></figure></section></section></section>
</body>
</html>
