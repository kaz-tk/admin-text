<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>ファイルシステムの管理</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" type="text/css" href="themes/packages/@vivliostyle/theme-techbook/theme.css">
</head>
<body>
<section class="level1" aria-labelledby="ファイルシステムの管理"><h1 id="ファイルシステムの管理">ファイルシステムの管理</h1><section class="level2" aria-labelledby="アクセス権の管理"><h2 id="アクセス権の管理">アクセス権の管理</h2><p>LinuxはPOSIXで示されているアクセス制御に準拠しています。POSIXとは「Portable Operating System Interface for UNIX」の略で、IEEEによって定められた、UNIXベースのOSの仕様セットです。ユーザID（uid）/グループID（gid）とパーミッションの組み合わせでファイルに対するアクセス権を管理しています。</p><section class="level3" aria-labelledby="uidとgid"><h3 id="uidとgid">UIDとGID</h3><p>ユーザID（uid：User Identifier)はLinuxシステムでユーザを識別するためのユニークな番号です。Linuxで追加されたユーザカウントには、それぞれ個別にuidが割り振られます。<br>
uidは0から65535までの値をとります。0は特別なユーザIDで、管理者権限を持つrootユーザに付与されています。</p><p>グループID（gid: Group Identifier）はグループを識別するためのユニークな番号です。Linuxのユーザは、1つ以上のグループに所属することができます。<br>
gidは0から65535までの値をとります。</p></section><section class="level3" aria-labelledby="検証用ユーザグループの確認"><h3 id="検証用ユーザグループの確認">検証用ユーザ、グループの確認</h3><p>アクセス制御の動作確認のため、検証用のユーザを用意します。すでに1章で作成していますが、作成されていない場合にはuseraddコマンド、grooupaddコマンドなどを使用して作成して下さい。</p><p>ユーザsatoとユーザsuzukiが作成されており、ユーザsuzukiはwheelグループとeigyouグループに所属しています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">id</span> sato</span></span>
<span class="token output">uid=500(sato) gid=500(sato) 所属グループ=500(sato)
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">id</span> suzuki</span></span>
<span class="token output">uid=501(suzuki) gid=501(suzuki) 所属グループ=501(suzuki),10(wheel),5000(eigyou)</span></code></pre></section><section class="level3" aria-labelledby="別々のユーザとして作業する"><h3 id="別々のユーザとして作業する">別々のユーザとして作業する</h3><p>ユーザsatoとユーザsuzuki での操作をスムーズに行うため、それぞれ別々のユーザでログインします。</p><p>Linuxサーバとは別の端末で操作を行っている場合には、それぞれのユーザでログインします。</p><p>Linuxサーバ上のX Window Systemで操作を行っている場合には、rootユーザでログインした後、別々のターミナルを起動し、suコマンドを使ってユーザを切り替えるとよいでしょう。</p><p>ターミナルAでユーザsatoに切り替えます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">su</span> - sato</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">id</span></span></span>
<span class="token output">uid=500(sato) gid=500(sato) 所属グループ=500(sato) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span></code></pre><p>ターミナルBでユーザsuzukiに切り替えます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">su</span> - suzuki</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">id</span></span></span>
<span class="token output">uid=501(suzuki) gid=501(suzuki) 所属グループ=501(suzuki),10(wheel),5000(eigyou) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span></code></pre></section><section class="level3" aria-labelledby="プロセスの実行権の管理"><h3 id="プロセスの実行権の管理">プロセスの実行権の管理</h3><p>Linuxでは、rootユーザを除いて他のユーザが起動したプロセスを停止させることはできません。</p><p>以下の例では、ユーザsatoでviエディタ（vim）を起動して/tmpにファイルを作成しようとしているプロセスをユーザsuzukiがkillコマンドで停止しようとしますが、停止できません。</p><p>ユーザsatoがviエディタで/tmp/satoを作成します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">vi</span> /tmp/sato</span></span></code></pre><p>ユーザsuzukiがvimプロセスを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">vim</span></span></span>
<span class="token output">sato      6456  0.1  0.3 148100  3692 pts/2    S+   19:46   0:00 vim /tmp/sato
suzuki    6462  0.0  0.0 107464   916 pts/3    S+   19:46   0:00 grep vim</span></code></pre><p>ユーザsuzukiがユーザsatoが実行中のvimエディタのプロセスをkillコマンドで停止しようとしますが、停止できません。指定するプロセスIDは、psコマンドの2番目の表示項目です。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">kill</span> <span class="token number">6456</span></span></span>
<span class="token output">-bash: kill: (6456) - 許可されていない操作です</span></code></pre><p>ユーザsatoは「:q!」と入力してvimエディタを終了します。</p></section><section class="level3" aria-labelledby="ファイルのアクセス権の管理"><h3 id="ファイルのアクセス権の管理">ファイルのアクセス権の管理</h3><p>ユーザsatoが作成したファイル/tmp/satoを使って、アクセス権の動作を検証します。</p><p>ユーザsatoでファイル/tmp/satoのアクセス権を確認します。その他のユーザへのアクセス権は読み取りのみ与えられています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/sato</span></span>
<span class="token output">-rw-rw-r--. 1 sato sato 5 12月  9 17:51 2014 /tmp/sato</span></code></pre><p>ユーザsuzukiでcatコマンドを実行し、ファイル/tmp/satoの内容を確認します。その他のユーザへの読み取りは許可されているので、内容を確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">cat</span> /tmp/sato</span></span>
<span class="token output">sato</span></code></pre><p>ユーザsuzukiでファイル/tmp/satoに追記してみます。書き込みのアクセス権は与えられていないのでエラーとなります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"suzuki"</span> <span class="token operator">>></span> /tmp/sato</span></span>
<span class="token output">-bash: /tmp/sato: 許可がありません</span></code></pre></section><section class="level3" aria-labelledby="umaskとデフォルトのパーミッションの関係"><h3 id="umaskとデフォルトのパーミッションの関係">umaskとデフォルトのパーミッションの関係</h3><p>umaskとは、ファイルやディレクトリが新規に作成される際にデフォルトのパーミッションを決定するための値です。umaskコマンドで確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span></span></span>
<span class="token output">0002</span></code></pre><p>umaskの設定値には、新しくファイルを作成する際に設定しない（許可しない）パーミッションを8進数で指定します。</p>






















<table><thead><tr><th></th><th>読み取り</th><th>書き込み</th><th>実行</th></tr></thead><tbody><tr><td>パーミッション</td><td>r</td><td>w</td><td>x</td></tr><tr><td>8進数値</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><p>ファイルとディレクトリでは設定されるデフォルトのパーミッションが変わるので、それぞれ確認してみましょう。</p></section><section class="level3" aria-labelledby="ファイル作成のパーミッションとumask"><h3 id="ファイル作成のパーミッションとumask">ファイル作成のパーミッションとumask</h3><p>ファイルが新規作成される際にはファイルの実行パーミッション(eXecute)は設定しないので、0666(rw-rw-rw-)に対してumaskの値が適用されます。</p><p>umaskが0002と設定されていると、その他のユーザの書き込みのパーミッション（w）が設定されていないファイル（-rw-rw-r--、0664）が作成されます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span></span></span>
<span class="token output">0002
</span><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">touch</span> testfile</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l testfile</span></span>
<span class="token output">-rw-rw-r--. 1 sato sato 0  1月 14 19:51 2015 testfile</span></code></pre></section><section class="level3" aria-labelledby="ディレクトリ作成のパーミッションとumask"><h3 id="ディレクトリ作成のパーミッションとumask">ディレクトリ作成のパーミッションとumask</h3><p>ディレクトリが新規作成される際には、実行パーミッション(eXecute)が必要になるので、0777(rwxrwxrwx)に対してumaskの値が適用されます。実行パーミッションが必要になるのは、1章でも説明したとおり、そのディレクトリをカレントディレクトリにするためには実行パーミッションが必要になるからです。</p><p>umaskが0002と設定されていると、その他のユーザの書き込みのパーミッション（w）が設定されないディレクトリ（-rwxrwxr-x、0775）が作成されています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span></span></span>
<span class="token output">0002
</span><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">mkdir</span> testdir</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -ld testdir</span></span>
<span class="token output">drwxrwxr-x. 2 sato sato 4096  1月 14 19:52 2015 testdir</span></code></pre></section><section class="level3" aria-labelledby="umaskが4桁の理由"><h3 id="umaskが4桁の理由">umaskが4桁の理由</h3><p>パーミッションは通常、ユーザ、グループ、その他のユーザの3つに対するアクセス権が設定されますが、umaskの値は4桁になっています。これは、通常のパーミッションの先頭に、setUID/setGID/スティッキービットを表す桁が含まれるためです。setUIDなどについては後述します。<br>
また、通常setUIDなどをデフォルトパーミッションとして設定することはないので、umaskは先頭を省略して3桁で設定することもできます。<br>
以下の例では、umaskを022と3桁で設定していますが、umaskコマンドの結果は0022になっています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span> 022</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span></span></span>
<span class="token output">0022</span></code></pre></section><section class="level3" aria-labelledby="umaskを変更する"><h3 id="umaskを変更する">umaskを変更する</h3><p>umaskを変更したい場合には、umaskコマンドで設定したumask値を引数として与えます。<br>
以下の例では、umaskの値を0022に変更したので、新規に作成したファイルのアクセス権は644(-rw-r--r--)に設定されています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span> 0022</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">touch</span> umasktest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l umasktest</span></span>
<span class="token output">-rw-r--r--. 1 sato sato 0  1月 14 19:53 2015 umasktest</span></code></pre></section><section class="level3" aria-labelledby="rootユーザのumaskとデフォルトのumask"><h3 id="rootユーザのumaskとデフォルトのumask">rootユーザのumaskとデフォルトのumask</h3><p>一般ユーザのumaskの値は0002ですが、rootユーザのumaskの値は0022に設定されています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token builtin class-name">umask</span></span></span>
<span class="token output">0022</span></code></pre><p>これは、bashシェルを起動する際に読み込まれるシェルスクリプト/etc/bashrcの中でデフォルトのumaskが設定されているためです。以下のように、uidが200以上で、かつuidとgidが同じ場合にはumaskの値は0002（002と3桁表記）、それ以外は0022に設定されるように処理されています。</p><p>同様の処理は/etc/profileでも行われています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">cat</span> /etc/bashrc</span></span>
<span class="token output">（略）
    # By default, we want umask to get set. This sets it for non-login shell.
    # Current threshold for system reserved uid/gids is 200
    # You could check uidgid reservation validity in
    # /usr/share/doc/setup-*/uidgid file
    if [ $UID -gt 199 ] &#x26;&#x26; [ "`id -gn`" = "`id -un`" ]; then
       umask 002
    else
       umask 022
    fi
（略）</span></code></pre><p>uidとgidが同じであることを確認しているのは、useraddコマンドでユーザアカウントを新規に作成すると、特別設定しない限り指定されたユーザ名と同じ名前のグループを作成し、uidとgidが同じになるためです。つまり、uidとgidが同じユーザは、useraddコマンドを使ってシンプルに作成されたユーザアカウントと判定できるということになります。</p></section><section class="level3" aria-labelledby="setuidの確認"><h3 id="setuidの確認">setUIDの確認</h3><p>setUIDが実行ファイルに設定されていると、その実行ファイルは所有ユーザの権限で実行されます。setUIDが設定されている場合、lsコマンドの出力で所有ユーザの実行パーミッションが「s」と表示されます。</p><p>setUIDが設定されている例として、passwdコマンドがあります。一般ユーザがパスワードを変更するには、rootユーザだけが書き込める/etc/shadowファイルに対する変更が必要です。パスワードを変更するpasswdコマンドは、所有ユーザがrootユーザでsetUIDが設定されているので、一般ユーザがpasswdコマンドを実行すると、rootユーザの権限で実行されて/etc/shadowファイルに変更を加えることができます。</p><p>コマンドを実行したユーザを「実行ユーザ」、setUIDで権限が変更されたユーザを「実効ユーザ」と呼びます。</p><p>以下の例では、passwdコマンドを一時停止して、psコマンドで実効ユーザを確認しています。</p><p>setUIDが設定されていることを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /usr/bin/passwd</span></span>
<span class="token output">-rwsr-xr-x. 1 root root 30768  2月 22 20:48 2012 /usr/bin/passwd</span></code></pre><p>passwdを実行し、Ctrl+Zキーで一時停止します。一時停止後、シェルプロンプトに戻すためにはEnterキーを押す必要があります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">passwd</span></span></span>
<span class="token output">ユーザー sato のパスワードを変更。
sato 用にパスワードを変更中
現在のUNIXパスワード: ※Ctrl+Zキーを入力後、Enterキーを押す
[1]+  停止                  passwd</span></code></pre><p>psコマンドで実効ユーザを確認します。passwdコマンドの実効ユーザがrootであることが確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">passwd</span></span></span>
<span class="token output">root     15052  0.0  0.2 164012  2068 pts/1    T    10:47   0:00 passwd
sato     15178  0.0  0.0 107464   916 pts/1    S+   10:48   0:00 grep passwd</span></code></pre><p>fgコマンドで一時停止したpasswdコマンドをフォアグラウンドプロセスに戻し、Ctrl+Cキーで終了します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">fg</span></span></span>
<span class="token output">passwd
※^C ←Ctrl+Cキーを入力
[sato@server ~]$</span></code></pre></section><section class="level3" aria-labelledby="setgidの確認"><h3 id="setgidの確認">setGIDの確認</h3><p>setGIDが設定されていると、所有グループの権限で実行されます。setGIDは所有グループの実行パーミッションが「s」と表示されます。</p><p>setGIDが設定されている例として、writeコマンドやslocateコマンドがあります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /usr/bin/write</span></span>
<span class="token output">-rwxr-sr-x  1 root tty 10124 2月 18日  2011 /usr/bin/write
</span><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /usr/bin/slocate</span></span>
<span class="token output">-rwxr-sr-x  1 root slocate 38516 11月 17日  2007 /usr/bin/slocate</span></code></pre><p>writeコマンドは、ログインしている他のユーザに対してメッセージを送るコマンドです。以下の例では、writeコマンドを一時停止して、psコマンドで実効グループを確認しています。</p><p>2つのユーザアカウントでログインします。同じユーザアカウントでも構いません。<br>
writeコマンドを実行し、Ctrl+Zキーで一時停止します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">write</span> suzuki</span></span>
<span class="token output">※^Z ←Ctrl+Zキーを入力
[1]+  停止                  write suzuki</span></code></pre><p>psコマンドで実効グループを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ps</span> a -eo <span class="token string">"%p %u %g %G %y %c"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">write</span></span></span>
<span class="token output">23400 sato     sato     ※tty※      pts/1    write</span></code></pre><p>表示は左から、プロセスID（%p）、実行ユーザ（%u）、実行グループ（%g）、実効グループ（%G）、実効端末（%y）、コマンド（%c）となっています。実行したのはユーザsatoですが、setGIDされているためttyグループとして動作していることが確認できます。</p><p>ttyとは「Tele-TYpewriter」の意味で、端末を表します。writeコマンドはログインしている他のユーザの端末にメッセージを表示するためにsetGIDを行って実効グループをttyグループにしているわけです。</p></section><section class="level3" aria-labelledby="スティッキービット"><h3 id="スティッキービット">スティッキービット</h3><p>スティッキービットが設定されたファイルやディレクトリは、「すべてのユーザが書き込めるが、所有者しか削除できない」というアクセス権限が設定されます。</p><p>たとえば/tmpディレクトリに対してスティッキービットが設定されています。/tmpディレクトリは全てのユーザやアプリケーションが書き込めるディレクトリとして、一時ファイルの作成などに使用されています。しかし/tmpディレクトリのパーミッションを777（rwxrwxrwx）に設定すると、作成したファイルを他のユーザが削除できてしまいます。そこで/tmpディレクトリにスティッキービットを設定すると、そのファイルを削除できるのは作成したユーザのみとなります。</p><p>スティッキービットが設定されていると、lsコマンドの出力でその他のユーザの実行パーミッションが「t」と表示されます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -ld /tmp</span></span>
<span class="token output">drwxrwxrwt. 16 root root 4096  1月 14 20:26 2015 /tmp</span></code></pre><p>ユーザsatoで/tmp/sbittestを作成し、パーミッションを666に設定します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">touch</span> /tmp/sbittest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">chmod</span> <span class="token number">666</span> /tmp/sbittest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/sbittest</span></span>
<span class="token output">-rw-rw-rw-. 1 sato sato 0  1月 14 20:28 2015 /tmp/sbittest</span></code></pre><p>ユーザsuzukiで/tmp/sbittestに書き込みをします。その他のユーザーに対する書き込みのパーミッションが付与されているので書き込みが行えます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"suzuki"</span> <span class="token operator">>></span> /tmp/sbittest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">cat</span> /tmp/sbittest</span></span>
<span class="token output">suzuki</span></code></pre><p>ユーザsuzukiで/tmp/sbittestを削除しようとしますが、スティッキービットが働いて削除できません。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">rm</span> /tmp/sbittest</span></span>
<span class="token output">rm: cannot remove `/tmp/sbittest': 許可されていない操作です</span></code></pre><p>ユーザsatoで/tmp/sbittestを削除します。所有ユーザは削除が行えます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">rm</span> /tmp/sbittest</span></span></code></pre></section></section><section class="level2" aria-labelledby="posix-acl"><h2 id="posix-acl">POSIX ACL</h2><p>ACL(Access Control List。POSIX準拠のACLのため、POSIX ACLとも呼ばれる)は、Linuxカーネル2.6から標準採用されており、従来のLinuxでのアクセス権限よりも細かにアクセス権限を設定できる技術です。<br>
Linux以外のOS、たとえばWindowsなどでもACLをサポートしており、付加できる権限の種類もより細やかなものになっています。Linuxでも、Windows向けのファイルサーバとしてSambaを利用する場合などには、同様のアクセス権限設定を行うためにACLが必要です。</p><section class="level3" aria-labelledby="aclを有効にする条件と確認"><h3 id="aclを有効にする条件と確認">ACLを有効にする条件と確認</h3><p>ACLはファイルシステムの拡張属性を利用しているため、拡張属性がサポートされているファイルシステムを用いる必要があります。ext3やext4、XFSなどほとんどのファイルシステムでは拡張属性がサポートされています。<br>
また、ファイルシステムによってはマウントする際にmountコマンドにaclオプションを指定する必要がありますが、CentOS 6で標準で利用しているext4ではデフォルトでACLが有効になっているので、aclオプションの指定は必要ありません。</p><p>ACLが使用できるかは、lsコマンドでパーミッションを確認した時に、パーミッションの最後に"."が表示されていることで判別できます。</p><p>"."は、そのファイルにACLが設定されていないことを意味しています。ACLが設定されると"+"に表示が変更されます。</p></section><section class="level3" aria-labelledby="aclの設定例"><h3 id="aclの設定例">ACLの設定例</h3><p>実際にACLを設定してみます。getfaclコマンドはファイルやディレクトリに対して、設定されているACLを表示するコマンドです。また、setfaclはファイルやディレクトリに対して、ACLを設定するコマンドです。</p><p>ユーザsatoで/tmp/acltestファイルを作成します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">touch</span> /tmp/acltest</span></span></code></pre><p>getfaclコマンドで/tmp/acltestファイルのACLを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">getfacl /tmp/acltest</span></span>
<span class="token output">getfacl: Removing leading '/' from absolute path names
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">file: tmp/acltest</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">owner: sato</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">group: sato</span></span>
<span class="token output">user::rw-
group::r--
other::r--</span></code></pre><p>ユーザsuzukiで/tmp/acltestファイルに書き込みをします。その他のユーザにはパーミッションが付与されていないので書き込みが行えません。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"suzuki"</span> <span class="token operator">>></span> /tmp/acltest</span></span>
<span class="token output">-bash: /var/tmp/acltest: 許可がありません</span></code></pre><p>ユーザsatoでsetfaclコマンドを実行して、ユーザsuzukiの/tmp/acltestに対する読み書きのACLを設定します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">setfacl -m u:suzuki:rw /tmp/acltest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">getfacl /tmp/acltest</span></span>
<span class="token output">getfacl: Removing leading '/' from absolute path names
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">file: tmp/acltest</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">owner: sato</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">group: sato</span></span>
<span class="token output">user::rw-
※user:suzuki:rw- ユーザsuzukiに対するACLが設定されている
group::rw-
mask::rw-
other::r--</span></code></pre><p>ユーザsuzukiで再度/tmp/acltestファイルに書き込みをします。ACLが設定されたので書き込みが行えます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"suzuki"</span> <span class="token operator">>></span> /tmp/acltest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">cat</span> /tmp/acltest</span></span>
<span class="token output">suzuki</span></code></pre><p>ユーザsatoでsetfaclコマンドを実行して、ユーザsuzukiの/tmp/acltestに対する読み書きのACLを削除します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">setfacl -x u:suzuki /tmp/acltest</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">getfacl /tmp/acltest</span></span>
<span class="token output">getfacl: Removing leading '/' from absolute path names
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">file: tmp/acltest</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">owner: sato</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">group: sato</span></span>
<span class="token output">user::rw-
group::rw-
mask::rw-
other::r--</span></code></pre><p>ユーザsuzukiで/tmp/acltestファイルに再度書き込みをします。ACLが削除されたので書き込みが行えません。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[suzuki@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"suzuki"</span> <span class="token operator">>></span> /tmp/acltest</span></span>
<span class="token output">-bash: /var/tmp/acltest: 許可がありません</span></code></pre></section><section class="level3" aria-labelledby="sambaとaclの関係"><h3 id="sambaとaclの関係">SambaとACLの関係</h3><p>SambaでWindowsクライアントに対してファイル共有を提供した際に、Windowsで設定した細かな権限はLinux上ではACLを用いて実現されています。</p><p>例として、/home/sato以下にsamba_ACL_testディレクトリを作成し、ACLの設定を行ってみます。</p><section class="level4" aria-labelledby="sambaのインストールと設定"><h4 id="sambaのインストールと設定">Sambaのインストールと設定</h4><p>Sambaをインストールします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">yum <span class="token function">install</span> samba</span></span></code></pre><p>Sambaの設定ファイル/etc/samba/smb.confのworkgroup設定を変更します。ワークグループ名はWindowsクライアントの参加しているワークグループに合わせます。WindowsクライアントのデフォルトのワークグループはWORKGROUPです。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">vi /etc/samba/smb.conf

        workgroup = ※WORKGROUP ←ワークグループ名を変更※</span></code></pre><p>Sambaを起動します。smbサービスとnmbサービスを起動します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> smb start</span></span>
<span class="token output">SMB サービスを起動中:                                      [  OK  ]
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> nmb start</span></span>
<span class="token output">NMB サービスを起動中:                                      [  OK  ]</span></code></pre></section><section class="level4" aria-labelledby="iptablesの設定変更"><h4 id="iptablesの設定変更">iptablesの設定変更</h4><p>iptablesの設定を変更します。system-config-firewall-tuiコマンドを実行してカスタマイズ設定でSambaを許可するか、/etc/sysconfig/iptablesに以下の4行を設定してiptablesサービスをreloadします。Sambaの使用しているSMB/CIFSプロトコルはTCPとUDPの2種類である点に注意してください。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">-A INPUT -m state --state NEW -m udp -p udp --dport 137 -j ACCEPT
-A INPUT -m state --state NEW -m udp -p udp --dport 138 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 139 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 445 -j ACCEPT</span></code></pre></section><section class="level4" aria-labelledby="selinuxの設定変更"><h4 id="selinuxの設定変更">SELinuxの設定変更</h4><p>SELinuxが有効な場合、SELinuxの設定を変更します。以下のsetseboolコマンドを実行して、Samba経由でユーザのホームディレクトリへのアクセスを許可します。SELinuxの設定については後述します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">setsebool -P samba_enable_home_dirs on</span></span></code></pre></section><section class="level4" aria-labelledby="sambaユーザの登録"><h4 id="sambaユーザの登録">Sambaユーザの登録</h4><p>smbpasswdコマンドでSambaユーザを登録します。ユーザアカウントはあらかじめLinuxに登録されているユーザアカウントを指定する必要があります。ここではユーザsatoを指定しています。入力したパスワードは、Windowsクライアントからファイル共有へアクセスする際の認証に使用します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">smbpasswd -a sato</span></span>
<span class="token output">New SMB password: ※パスワードを入力
Retype new SMB password: ※パスワードを再入力
Added user sato.</span></code></pre></section><section class="level4" aria-labelledby="windowsクライアントからsambaへのアクセス"><h4 id="windowsクライアントからsambaへのアクセス">WindowsクライアントからSambaへのアクセス</h4><p>WindowsクライアントからSambaのファイル共有にアクセスします。</p><ol>
<li>Sambaへのアクセスを指定します。</li>
</ol><figure><img src="samba0.png" alt="Sambaへのアクセス"><figcaption aria-hidden="true">Sambaへのアクセス</figcaption></figure><p>「スタート」ボタン→「プログラムとファイルの検索」に「\server\」、あるいは「\192.168.0.10」と入力します。</p><p>＃2</p><ol start="2">
<li>ユーザ認証を行います。</li>
</ol><figure><img src="samba1.png" alt="ユーザ認証"><figcaption aria-hidden="true">ユーザ認証</figcaption></figure><p>ユーザ認証が要求された場合には、前の手順で登録したユーザ名、パスワードで認証を行います。</p><p>＃3</p><ol start="3">
<li>ユーザホーム共有にアクセスします。</li>
</ol><figure><img src="samba2.png" alt="ユーザホーム共有"><figcaption aria-hidden="true">ユーザホーム共有</figcaption></figure><p>ユーザアカウント名のファイル共有（sato）のアイコンをダブルクリックで開きます。これはSambaがユーザのホームディレクトリを自動的に共有として扱う、ユーザホーム共有の機能を使っています。</p><p>＃4</p><ol start="4">
<li>テスト用のフォルダを作成します。</li>
</ol><figure><img src="samba3.png" alt="samba_acl_testフォルダ"><figcaption aria-hidden="true">samba_acl_testフォルダ</figcaption></figure><p>samba_acl_testフォルダを作成します。</p><p>＃5</p><ol start="5">
<li>フォルダのプロパティウインドウを呼び出します。</li>
</ol><figure><img src="samba4.png" alt="プロパティ"><figcaption aria-hidden="true">プロパティ</figcaption></figure><p>Windowsクライアントでsamba_acl_testフォルダを右クリックして、「プロパティ」を選択します。「セキュリティ」タブをクリックして、「詳細設定」ボタンをクリックします。</p><p>＃6</p><ol start="6">
<li>アクセス許可エントリを確認します。</li>
</ol><figure><img src="samba5.png" alt="読み書きのみ"><figcaption aria-hidden="true">読み書きのみ</figcaption></figure><p>「Everyone」をダブルクリックして、「許可」が5つチェックされていることを確認します。「OK」ボタンをクリックします。さらにOKボタンをクリックして、プロパティのウインドウに戻ります。</p></section><section class="level4" aria-labelledby="linuxからaclを確認"><h4 id="linuxからaclを確認">LinuxからACLを確認</h4><ol>
<li>ユーザsatoでログインし、ホームディレクトリに作られたsamba_acl_testディレクトリのACLを確認します。</li>
</ol><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">getfacl samba_acl_test/</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">file: samba_acl_test/</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">owner: sato</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">group: sato</span></span>
<span class="token output">user::rwx
group::r-x
other::r-x</span></code></pre><p>＃2</p><ol start="2">
<li>setfaclコマンドを実行して、samba_acl_testディレクトリに対して、その他のユーザに書き込みのACLを付与します。</li>
</ol><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">setfacl -m o::rwx samba_acl_test</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash">getfacl samba_acl_test/</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">file: samba_acl_test/</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">owner: sato</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">group: sato</span></span>
<span class="token output">user::rwx
group::r-x
other::r※w※x ※←書き込み権限が付与されている</span></code></pre><p>＃3</p><ol start="3">
<li>Windowsクライアントで再度アクセス許可エントリを確認します。</li>
</ol><figure><img src="samba5.png" alt="すべてのアクセス許可"><figcaption aria-hidden="true">すべてのアクセス許可</figcaption></figure><p>Windowsクライアントで再度「詳細設定」ボタンをクリックします。「Everyone」をダブルクリックして、すべてのアクセス許可項目がチェックされていることを確認します。</p></section></section></section><section class="level2" aria-labelledby="selinux"><h2 id="selinux">SELinux</h2><p>SELinuxはLinuxカーネル2.6から実装された、rootユーザの特権に対しても制限を掛けることができる強制アクセス制御（MAC、Mandatory Access Control）の仕組みです。</p><p>本教科書では、SELinuxの基本的な管理について解説します。SELinuxのより詳しい説明については、『Linuxセキュリティ標準教科書』を参照してください。</p><section class="level3" aria-labelledby="selinuxの仕組み"><h3 id="selinuxの仕組み">SELinuxの仕組み</h3><p>SELinuxでは、プロセスやファイルなどLinuxの全てのリソースに対して「コンテキスト」（contexts）と呼ばれるラベルを付加し、「サブジェクト」（subject。アクセスする側。主にプロセス）が「オブジェクト」（object。アクセスされる側。主にファイルやディレクトリ、プロセス）に対してアクセスを行う際に、そのコンテキストを比較することによりアクセス制御を行います。</p><p>複数のコンテキストを組み合わせて、アクセスの可否を行うルールをSELinuxでは「ポリシー」と呼びます。ポリシーの詳細な説明と修正に関しては、『Linuxセキュリティ標準教科書』を参照してください。</p></section><section class="level3" aria-labelledby="selinuxの有効無効の確認"><h3 id="selinuxの有効無効の確認">SELinuxの有効、無効の確認</h3><p>SELinuxの状態はgetenforceコマンドで確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getenforce</span></span>
<span class="token output">Enforcing</span></code></pre><p>getenforceコマンドの結果は以下の通りです。</p>




















<table><thead><tr><th>結果</th><th>状態</th></tr></thead><tbody><tr><td>Enforcing</td><td>SELinuxによるアクセス制御が有効</td></tr><tr><td>Permissive</td><td>SELinuxは有効であるが動作拒否は行わない</td></tr><tr><td>Disabled</td><td>SELinuxによるアクセス制御が無効</td></tr></tbody></table><p>SELinuxの状態は、setenforceコマンドによる動的な変更か、設定ファイル/etc/selinux/configによる静的な変更のいずれかで変更できます。</p></section><section class="level3" aria-labelledby="setenforceコマンドによるselinuxの動的な変更"><h3 id="setenforceコマンドによるselinuxの動的な変更">setenforceコマンドによるSELinuxの動的な変更</h3><p>setenforceコマンドでSELinuxの状態を動的に変更できます。変更はrootユーザで実行する必要があります。</p><p>ただし、動的に変更できるのはEnforcingとPermissiveの切り替えのみで、SELinuxを有効から無効（Disabled）に、あるいは無効から有効に変更することはできません。<br>
有効、無効の切り替えは、後述する設定ファイルによる静的な変更とシステムの再起動が必要です。</p><pre class="language-text"><code class="language-text">setenforce [ Enforcing | Permissive | 1 | 0 ]</code></pre><p>たとえば、システムのSELinuxによるアクセス制御を一時的に適用しないようにしたいときには状態をPermissiveに変更します。SELinuxによるアクセス制御での動作の拒否は行われなくなりますが、デバッグなどの用途のためにSELinuxのポリシー違反が発生するとログは出力されます。<br>
システムが思ったように動作せず、SELinuxが原因と思われる時などにPermissiveに設定して、SELinuxが原因かどうかの切り分け作業を行います。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">setenforce permissive</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getenforce</span></span>
<span class="token output">Permissive</span></code></pre></section><section class="level3" aria-labelledby="selinuxの無効化"><h3 id="selinuxの無効化">SELinuxの無効化</h3><p>SELinuxを無効にする、あるいは無効から有効に変更するにはSELinuxの設定ファイル/etc/selinux/configの設定を変更します。システムを再起動すると、設定が反映されます。</p><p>/etc/selinux/configを編集し、設定項目SELINUXの値をdisabledに変更します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/selinux/config</span></span>

<span class="token output">※#※SELINUX=enforcing ※←行頭に#を追加
※SELINUX=disabled ←新たに追加</span></code></pre><p>システムを再起動します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">reboot</span></span></span></code></pre><p>getenforceコマンドでSELinuxが無効（Disabled）になったことを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getenforce</span></span>
<span class="token output">Disabled</span></code></pre><p>/etc/selinux/configを編集し、設定項目SELINUXの値をenforcingに変更します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/selinux/config</span></span>

<span class="token output">SELINUX=enforcing ※←行頭の#を削除
※#※SELINUX=disabled ※←行頭に#を追加</span></code></pre><p>システムを再起動します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">reboot</span></span></span></code></pre><p>getenforceコマンドでSELinuxが有効（Enforcing）になったことを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getenforce</span></span>
<span class="token output">Enforcing</span></code></pre></section><section class="level3" aria-labelledby="コンテキストの確認"><h3 id="コンテキストの確認">コンテキストの確認</h3><p>コンテキストはファイルなどに設定され、アクセス制御に利用されます。コンテキストは、次の4つの識別子で構成されています。</p><ul>
<li>ユーザ(user)</li>
<li>ロール(role)</li>
<li>タイプ(type)：プロセスの場合には特に「ドメイン」とも言います</li>
<li>MLS：高度なMulti Level Securityを提供できますが、通常のシステムではあまり使われません</li>
</ul><p>コンテキストは、これらの識別子を組み合わせて、以下の形式で表されます。</p><pre class="language-text"><code class="language-text">ユーザ:ロール:タイプ:MLSレベル</code></pre><p>SELinuxでのアクセス制御は、タイプ／ドメインに対して許可する動作を定義した「ポリシー」に基づいて行われます。タイプ／ドメインの名前は、役割やプロセス名からつけられています。たとえば、Apache Webサーバのプロセスであるhttpdには「httpd_t」というドメインがつけられています。</p></section><section class="level3" aria-labelledby="コンテキストの確認-1"><h3 id="コンテキストの確認-1">コンテキストの確認</h3><p>SELinuxのアクセス制御で用いられるコンテキストは、プロセスやファイルを参照するコマンドに-Zオプションをつけて実行することで確認できます。</p><p>たとえば、ファイルやディレクトリに付与されているコンテキストを確認するにはls -lZコマンドを実行します。例として、Apache Webサーバ（httpd）に関するファイルを確認してみます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -lZ /var/www</span></span>
<span class="token output">drwxr-xr-x. root root system_u:object_r:httpd_sys_script_exec_t:s0 cgi-bin
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 error
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 html
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 icons</span></code></pre><p>/var/www/htmlディレクトリや/var/www/iconsディレクトリなど、Webサーバのコンテンツを含むディレクトリには「httpd_sys_content_t」というタイプが付与されています。この/var/www/htmlディレクトリ内にファイルを作成すると、親ディレクトリのコンテキストに従ってファイルにコンテキストが付与されます。</p><p>確認のために、/var/www/htmlディレクトリ以下にindex.htmlファイルを作成してみます。<br>
親ディレクトリからコンテキストを継承し、index.htmlファイルに「httpd_sys_content_t」というタイプが付与されています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">touch</span> /var/www/html/index.html</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -lZ /var/www/html/index.html</span></span>
<span class="token output">-rw-r--r--. root root unconfined_u:object_r:※httpd_sys_content_t※:s0 /var/www/html/index.html</span></code></pre><p>また、プロセスのコンテキストの情報を確認するには、ps axZコマンドを実行します。</p><p>以下の例では、httpdのプロセスを確認すると、httpd_tドメインが付与されていることが分かります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> httpd start</span></span>
<span class="token output">httpd を起動中:                                            [  OK  ]
</span><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ps</span> axZ <span class="token operator">|</span> <span class="token function">grep</span> httpd</span></span>
<span class="token output">unconfined_u:system_r:httpd_t:s0 27104 ?       Ss     0:00 /usr/sbin/httpd
unconfined_u:system_r:httpd_t:s0 27106 ?       S      0:00 /usr/sbin/httpd
（略）</span></code></pre><p>SELinuxのポリシーでは、httpdプロセスに付与されているhttpd_tドメインが、「httpd_sys_content_t」などのタイプが付与されているファイルにread（読み取り）などが行えるように権限が設定されています。</p></section><section class="level3" aria-labelledby="booleanを使ったselinuxの制御"><h3 id="booleanを使ったselinuxの制御">Booleanを使ったSELinuxの制御</h3><p>SELinuxを有効にしてアプリケーションがうまく動作しない場合には、SELinuxのアクセス制御によってプロセスがファイルやディレクトリにアクセスできないことが原因の場合があります。そのような時には、SELinuxのポリシーを設定する必要があります。</p><p>一般的なポリシーの設定は「Boolean」（ブーリアン）と呼ばれる設定の有効、無効で対応できます。Booleanで設定できる項目は、CentOS 6では、200種ほどあります。</p><p>もし、独自のアプリケーションを使用したり、アプリケーションの設定を大幅に変更した場合には、ポリシーを追加、修正する必要があります。ポリシーの追加、修正方法については『Linuxセキュリティ標準教科書』を参照してください。</p><p>以下の例では、Apache Webサーバ(httpd)に関するポリシーを設定しています。</p><p>getseboolコマンドでBooleanの設定状況一覧を確認します。Boolean名には関係するプロセス名が含まれているので、grepコマンドで「httpd」をキーワードにして検索します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getsebool -a <span class="token operator">|</span> <span class="token function">grep</span> httpd</span></span>
<span class="token output">allow_httpd_anon_write --> off
allow_httpd_mod_auth_ntlm_winbind --> off
（略）
httpd_enable_homedirs --> off
（略）</span></code></pre><p>後の作業でhttpd_enable_homedirsのBooleanを設定します。このBooleanは、Apache Webサーバのユーザホームディレクトリ機能に関する設定です。ユーザホームディレクトリ機能は、各ユーザのホームディレクトリに作成されたpublic_htmlディレクトリ内をWebコンテンツとして公開する仕組みです。</p><p>Apache Webサーバの設定ファイル/etc/httpd/conf/httpd.confを修正し、UserDirディレクティブを設定してユーザホームディレクトリ機能を有効にします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/httpd/conf/httpd.conf</span></span>

<span class="token output">（略）
&#x3C;IfModule mod_userdir.c>
    #
    # UserDir is disabled by default since it can confirm the presence
    # of a username on the system (depending on home directory
    # permissions).
    #
    ※#※UserDir disabled ※←行頭に#を追加

    #
    # To enable requests to /~user/ to serve the user's public_html
    # directory, remove the "UserDir disabled" line above, and uncomment
    # the following line instead:
    #
    UserDir public_html ※←行頭の#を削除
（略）</span></code></pre><p>httpdサービスを再起動します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">service</span> httpd restart</span></span>
<span class="token output">httpd を停止中:                                            [  OK  ]
httpd を起動中:                                            [  OK  ]</span></code></pre><p>ユーザsatoでログインし、ホームディレクトリにpublic_htmlディレクトリを作成します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">pwd</span></span></span>
<span class="token output">/home/sato
</span><span class="token command"><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token function">mkdir</span> public_html</span></span></code></pre><p>/home/satoディレクトリ、/home/sato/public_htmlディレクトリのパーミッションを711に設定します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token output">chmod 711 /home/sato
chmod 711 /home/sato/public_html/</span></code></pre><p>public_htmlディレクトリにindex.htmlファイルを作成します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[sato@server ~]</span></span><span class="token shell-symbol important">$</span> <span class="token bash language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"SELinux test"</span> <span class="token operator">></span> /home/sato/public_html/index.html</span></span></code></pre><p>ブラウザを起動し、「<a href="http://192.168.0.10/~sato/%E3%80%8D%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82SELinux%E3%81%AE%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E5%88%B6%E5%BE%A1%E3%81%8C%E6%9C%89%E5%8A%B9%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E3%80%8CForbidden%E3%80%8D%E3%81%8C%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82">http://192.168.0.10/~sato/」にアクセスします。SELinuxのアクセス制御が有効になっているため、「Forbidden」が表示されます。</a></p><figure><img src="Forbidden.png" alt="Forbidden"><figcaption aria-hidden="true">Forbidden</figcaption></figure><p>rootユーザでログファイル/var/log/audit/audit.logを確認します。httpd(httpd_t)がユーザホームディレクトリ(user_home_dir_t)にアクセスできなかったというログが出力されています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">tail</span> /var/log/audit/audit.log</span></span>
<span class="token output">（略）
type=AVC msg=audit(1421241819.317:804): avc:  ※denied  { search }※ for  pid=7357 comm="httpd" name="sato" dev=dm-2 ino=130305 scontext=unconfined_u:system_r:※httpd_t※:s0 tcontext=unconfined_u:object_r:※user_home_dir_t※:s0 tclass=dir
type=SYSCALL msg=audit(1421241819.317:804): arch=c000003e syscall=4 success=no exit=-13 a0=7f7f0adf26e8 a1=7fff803d37c0 a2=7fff803d37c0 a3=1999999999999999 items=0 ppid=7352 pid=7357 auid=0 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=87 comm="httpd" exe="/usr/sbin/httpd" subj=unconfined_u:system_r:※httpd_t※:s0 key=(null)
type=AVC msg=audit(1421241819.317:805): avc:  ※denied  { getattr }※ for  pid=7357 comm="httpd" ※path="/home/sato"※ dev=dm-2 ino=130305 scontext=unconfined_u:system_r:※httpd_t※:s0 tcontext=unconfined_u:object_r:※user_home_dir_t※:s0 tclass=dir
type=SYSCALL msg=audit(1421241819.317:805): arch=c000003e syscall=6 success=no exit=-13 a0=7f7f0adf2798 a1=7fff803d37c0 a2=7fff803d37c0 a3=1 items=0 ppid=7352 pid=7357 auid=0 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=87 comm="httpd" exe="/usr/sbin/httpd" subj=unconfined_u:system_r:※httpd_t※:s0 key=(null)</span></code></pre><p>setseboolコマンドを実行して、Boolean「httpd_enable_homedirs」を有効に設定します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getsebool httpd_enable_homedirs</span></span>
<span class="token output">httpd_enable_homedirs --> off
</span><span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash">setsebool httpd_enable_homedirs on</span></span>
<span class="token command"><span class="token info punctuation"><span class="token user">[root@server ~]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash">getsebool httpd_enable_homedirs</span></span>
<span class="token output">httpd_enable_homedirs --> on</span></code></pre><p>再度ブラウザで「<a href="http://192.168.0.10/~sato/%E3%80%8D%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82Boolean%E3%81%A7%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%8C%E8%A8%B1%E5%8F%AF%E3%81%95%E3%82%8C%E3%81%9F%E3%81%AE%E3%81%A7%E3%80%81%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%8C%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82">http://192.168.0.10/~sato/」にアクセスします。Booleanでアクセスが許可されたので、作成したページが表示されます。</a></p></section></section><section class="level2" aria-labelledby="lvmの設定"><h2 id="lvmの設定">LVMの設定</h2><p>LVM（Logical Volume Manager）は、ハードディスクなどの記憶媒体の物理的な状態を隠蔽し、論理的なイメージで管理するための技術です。</p><p>LVMを使うことで、複数のハードディスクにまたがったボリュームが作成できるようになり、ファイルシステムの容量が足りなくなった場合の容量の追加が簡単になります。ボリュームの操作は、システムを再起動することなく行うことができます。</p><p>また、ハードディスクに障害が発生した時には、新しいHDDを追加して、壊れているHDDを外すなどの障害対応が容易になります。<br>
他にも、スナップショットを取ることができるなどのメリットがあります。</p><p>現在の一般的なLinuxディストリビューションでは、インストール時にLVMでパーティションを作成できます。CentOSでは、インストール時に自動パーティション設定を選択すると、デフォルトでLVMを使用してストレージを設定します。</p><p>LVMの詳しい説明に関しては、『高信頼システム構築標準教科書』を参照してください。</p><p>LVMは、物理ボリューム（PV: Physical Volume）、ボリュームグループ（VG: Volume Group）、論理ボリューム（LV: Logical Volume）の3つで構成されています。</p><section class="level3" aria-labelledby="物理ボリュームpv"><h3 id="物理ボリュームpv">物理ボリューム（PV）</h3><p>物理ボリューム(PV)は、物理ディスクのパーティション単位で扱われます。一つの物理ディスクすべてを一つのPVとして扱うこともできますし、一つの物理ディスク内にパーティションを複数作成し、それぞれのパーティションを別々のPVとして扱うこともできます。</p><p>PVを作成するには、パーティションを作成し、パーティションタイプを8Eに設定します。</p><p>以下の例では、Linuxマシンに新規に追加した/dev/sdbとして認識されているハードディスクをLVMで使用できるよう、fdiskでパーティションを作成してPVとして設定しています。同時に、後の作業で領域拡張を行うための追加パーティションも作成しておきます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">fdisk</span> /dev/sdb</span></span>
<span class="token output">デバイスは正常な DOS 領域テーブルも、Sun, SGI や OSF ディスクラベルも
含んでいません
（略）

コマンド (m でヘルプ): ※n ←新規パーティション作成のnを入力
コマンドアクション
   e   拡張
   p   基本パーティション (1-4)
※p ←基本パーティションのpを入力
パーティション番号 (1-4): ※1 ←パーティション番号1を入力
最初 シリンダ (1-8354, 初期値 1): ※1 ←パーティション番号1を入力
Last シリンダ, +シリンダ数 or +size{K,M,G} (1-8354, 初期値 8354): ※+2G ←容量として+2GBを入力

コマンド (m でヘルプ): ※n ←新規パーティション作成のnを入力
コマンドアクション
   e   拡張
   p   基本パーティション (1-4)
※p ←基本パーティションのpを入力
パーティション番号 (1-4): ※2 ←パーティション番号2を入力
最初 シリンダ (263-8354, 初期値 263): ※Enterキーを入力
初期値 263 を使います
Last シリンダ, +シリンダ数 or +size{K,M,G} (263-8354, 初期値 8354): ※+2G ←容量として+2GBを入力

コマンド (m でヘルプ): ※t ←パーティションタイプ変更のtを入力
パーティション番号 (1-4): ※1 ←パーティション番号1を入力
16進数コード (L コマンドでコードリスト表示): ※8e ←LVM用の8eを入力
領域のシステムタイプを 1 から 8e (Linux LVM) に変更しました

コマンド (m でヘルプ): ※t ←パーティションタイプ変更のtを入力
パーティション番号 (1-4): ※2 ←パーティション番号2を入力
16進数コード (L コマンドでコードリスト表示): ※8e ←LVM用の8eを入力
領域のシステムタイプを 2 から 8e (Linux LVM) に変更しました

コマンド (m でヘルプ): ※w ←パーティション情報を書き込むwを入力
パーティションテーブルは変更されました！

ioctl() を呼び出してパーティションテーブルを再読込みします。
ディスクを同期しています。</span></code></pre></section><section class="level3" aria-labelledby="ボリュームグループvg"><h3 id="ボリュームグループvg">ボリュームグループ（VG）</h3><p>ボリュームグループ(VG)は、1つ以上の物理ボリューム（PV）をひとまとめにしたものです。これは仮想的なディスクに相当します。</p><p>ボリュームグループはvgcreateコマンドで作成します。</p><pre class="language-text"><code class="language-text">vgcreate ボリューム名 PVデバイス名 [PVデバイス名 ...]</code></pre><p>たとえば、物理ボリューム（PV）として作成した/dev/sdb1を使ってVolume00という名前のボリュームグループを作成するには、以下のvgcreateコマンドを実行します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">vgcreate Volume00 /dev/sdb1</span></span>
<span class="token output">  Physical volume "/dev/sdb1" successfully created
  Volume group "Volume00" successfully created</span></code></pre><p>また、ボリュームグループの情報はvgscanコマンドで確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">vgscan</span></span>
<span class="token output">  Reading all physical volumes.  This may take a while...
  Found volume group "Volume00" using metadata type lvm2
  Found volume group "vg_server" using metadata type lvm2</span></code></pre></section><section class="level3" aria-labelledby="論理ボリュームlv"><h3 id="論理ボリュームlv">論理ボリューム（LV）</h3><p>論理ボリューム（LV）は、ボリュームグループ（VG）上に作成する仮想的なパーティションです。Linuxからはデバイスとして認識されます。ハードディスクに物理パーティションを作成する場合と同様に、ボリュームグループをすべて一つの論理ボリュームとすることもできますし、一つのボリュームグループを複数の論理ボリュームに分割して使用することもできます。</p><p>論理ボリュームはlvcreateコマンドを使って作成します。</p><pre class="language-text"><code class="language-text">lvcreate -L サイズ -n 論理ボリューム名 ボリュームグループ名</code></pre><p>たとえば、ボリュームグループVolume00にサイズ1GB、論理ボリューム名「LogVol01」の論理ボリュームを作成するには、以下のlvcreateコマンドを実行します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">lvcreate -L 1024M -n LogVol01 Volume00</span></span></code></pre></section><section class="level3" aria-labelledby="論理ボリュームにファイルシステムの作成"><h3 id="論理ボリュームにファイルシステムの作成">論理ボリュームにファイルシステムの作成</h3><p>作成した論理ボリュームを利用するには、通常のパーティションと同じく論理ボリューム上にファイルシステムを作成します。論理ボリュームは、以下のようなデバイスとして扱うことができます。</p><pre class="language-text"><code class="language-text">/dev/ボリュームグループ名/論理ボリューム名</code></pre><p>/dev/Volume00/LogVol01上にext4ファイルシステムを作成するために、mkfsコマンドを実行します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mkfs</span> -t ext4 /dev/Volume00/LogVol01</span></span>
<span class="token output">mke2fs 1.41.12 (17-May-2010)
Discarding device blocks: done
Filesystem label=
OS type: Linux
（略）
This filesystem will be automatically checked every 33 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.</span></code></pre><p>mountコマンドを使って、/dev/Volume00/LogVol01をマウントします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mkdir</span> /mnt/LVMtest</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mount</span> -t ext4 /dev/Volume00/LogVol01 /mnt/LVMtest/</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mount</span> /mnt/LVMtest/</span></span>
<span class="token output">mount: /dev/mapper/Volume00-LogVol01 は マウント済か /mnt/LVMtest が使用中です
mount: mtab によると、/dev/mapper/Volume00-LogVol01 は /mnt/LVMtest にマウント済です</span></code></pre></section><section class="level3" aria-labelledby="ボリュームグループへのディスクの追加"><h3 id="ボリュームグループへのディスクの追加">ボリュームグループへのディスクの追加</h3><p>既存のボリュームグループVolume00に物理ボリューム/dev/sdb2を追加します。</p><p>vgextendコマンドを実行して、物理ボリューム/dev/sdb2をボリュームグループVolume00に追加します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">vgextend Volume00 /dev/sdb2</span></span>
<span class="token output">  Physical volume "/dev/sdb2" successfully created
  Volume group "Volume00" successfully extended</span></code></pre><p>vgdisplayコマンドを実行して、ボリュームグループVolume00の情報を確認します。PV（Physical volume）の数が2となっており、/dev/sdb2が加わっていることが分かります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">vgdisplay Volume00</span></span>
<span class="token output">  --- Volume group ---
  VG Name               Volume00
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  3
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                ※2
  Act PV                ※2
  VG Size               4.01 GiB
  PE Size               4.00 MiB
  Total PE              1026
  Alloc PE / Size       256 / 1.00 GiB
  Free  PE / Size       770 / 3.01 GiB
  VG UUID               yTTwWd-G5tb-FzNb-Ow0L-ebvr-1n9I-ikLWo2</span></code></pre></section><section class="level3" aria-labelledby="論理ボリュームの拡張"><h3 id="論理ボリュームの拡張">論理ボリュームの拡張</h3><p>LVMでは、論理ボリュームのサイズを変更できます。また、LVMの論理ボリューム上に作成されたext4ファイルシステムは、ファイルシステムをマウントしたまま拡張できます。</p><p>dfコマンドを実行して、現在のファイルシステムの容量を確認します。現在の容量は1GBです。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">df</span> /mnt/LVMtest/</span></span>
<span class="token output">Filesystem           1K-blocks  Used Available Use% Mounted on
/dev/mapper/Volume00-LogVol01
                        999320  1284    945608   1% /mnt/LVMtest</span></code></pre><p>lvextendコマンドを実行して、論理ボリュームLogVol01のサイズを2Gまで拡大します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">lvextend -L 2G /dev/Volume00/LogVol01</span></span>
<span class="token output"> Size of logical volume Volume00/LogVol01 changed from 1.00 GiB (256 extents) to 2.00 GiB (512 extents).
  Logical volume LogVol01 successfully resized</span></code></pre><p>resize2fsコマンドを実行して、ファイルシステムを拡大します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">resize2fs /dev/Volume00/LogVol01</span></span>
<span class="token output">resize2fs 1.41.12 (17-May-2010)
Filesystem at /dev/Volume00/LogVol01 is mounted on /mnt/LVMtest; on-line resizing required
old desc_blocks = 1, new_desc_blocks = 1
Performing an on-line resize of /dev/Volume00/LogVol01 to 524288 (4k) blocks.
The filesystem on /dev/Volume00/LogVol01 is now 524288 blocks long.</span></code></pre><p>dfコマンドで再度容量を確認します。容量が2GBに増えていることが確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">df</span> /mnt/LVMtest/</span></span>
<span class="token output">Filesystem           1K-blocks  Used Available Use% Mounted on
/dev/mapper/Volume00-LogVol01
                       2031440  1536   1925060   1% /mnt/LVMtest</span></code></pre></section><section class="level3" aria-labelledby="論理ボリュームの縮小"><h3 id="論理ボリュームの縮小">論理ボリュームの縮小</h3><p>運用上、他の論理ボリュームを拡大したい等の理由で使用率の低い論理ボリュームの縮小を行う場合があります。<br>
論理ボリュームを縮小するには、先にファイルシステムを縮小し、その後に論理ボリュームを縮小する必要があります。ファイルシステムの縮小はマウントしたままでは行えないので、作業中は一度アンマウントしておく必要があります。</p><p>縮小したいボリュームをアンマウントします。umountコマンドを実行して、/mnt/LVMtestをアンマウントします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">umount</span> /mnt/LVMtest/</span></span></code></pre><p>縮小したい論理ボリューム/dev/Volume00/LogVol01に対してfsckコマンドを実行します。強制的にチェックを行うために-fオプションを付与して実行します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">fsck</span> -f /dev/Volume00/LogVol01</span></span>
<span class="token output">fsck from util-linux-ng 2.17.2
e2fsck 1.41.12 (17-May-2010)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/mapper/Volume00-LogVol01: 11/131072 files (0.0% non-contiguous), 16812/524288 blocks</span></code></pre><p>resize2fsコマンドを実行して、ファイルシステムを縮小します。例として、1GBまで縮小します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">resize2fs /dev/Volume00/LogVol01 1G</span></span>
<span class="token output">resize2fs 1.41.12 (17-May-2010)
Resizing the filesystem on /dev/Volume00/LogVol01 to 262144 (4k) blocks.
The filesystem on /dev/Volume00/LogVol01 is now 262144 blocks long.</span></code></pre><p>lvreduceコマンドを実行して、論理ボリューム/dev/Volume00/LogVol01を縮小します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">lvreduce -L 1G /dev/Volume00/LogVol01</span></span>
<span class="token output">  WARNING: Reducing active logical volume to 1.00 GiB
  THIS MAY DESTROY YOUR DATA (filesystem etc.)
Do you really want to reduce LogVol01? [y/n]: ※y ←yを入力
  Size of logical volume Volume00/LogVol01 changed from 2.00 GiB (512 extents) to 1.00 GiB (256 extents).
  Logical volume LogVol01 successfully resized</span></code></pre><p>/mnt/LVMtestに再マウントして、容量を確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mount</span> -t ext4 /dev/Volume00/LogVol01 /mnt/LVMtest/</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">df</span> /mnt/LVMtest/</span></span>
<span class="token output">Filesystem           1K-blocks  Used Available Use% Mounted on
/dev/mapper/Volume00-LogVol01
                        999320  1284    945616   1% /mnt/LVMtest</span></code></pre></section></section><section class="level2" aria-labelledby="バックアップリストア"><h2 id="バックアップリストア">バックアップ／リストア</h2><p>システムを運用していく際には、バックアップは重要です。特に障害からシステムを復旧させるときや、重要なファイルを誤って削除したりするリスクを考えると、きちんとバックアップ／リストアのプランを立てて、前もってテストをしておくことが重要です。</p><section class="level3" aria-labelledby="バックアップメディアについて"><h3 id="バックアップメディアについて">バックアップメディアについて</h3><p>最近のストレージの大容量化を考えると、システムとは別のハードディスクにバックアップを取るのが一番簡単な手段です。また、容量を簡単に増やすことができるファイルサーバは、ネットワークを経由したバックアップ先の対象としてもよく利用されています。<br>
また、昔から使われているテープは現在でもバックアップメディアとしてよく利用されています。<br>
他にも、バックアップ対象の容量が多くない場合にはCDやDVDもバックアップメディアの候補となります。ただし、媒体の寿命が比較的短いため、長期保存する場合には保管場所などに注意が必要です。</p></section><section class="level3" aria-labelledby="代表的なバックアップツール"><h3 id="代表的なバックアップツール">代表的なバックアップツール</h3><p>企業等の運用現場ではバックアップ専用の商用ソフトウェアが多く使われていますが、Linuxで標準で利用可能な様々なツールも使用されています。それらの中でも代表的な以下のツールについて解説します。</p><ul>
<li>ddコマンド</li>
<li>dumpコマンド</li>
<li>tarコマンド</li>
<li>rsyncコマンド</li>
</ul></section><section class="level3" aria-labelledby="ddコマンド"><h3 id="ddコマンド">ddコマンド</h3><p>ディスク全体のイメージを出力するツールです。ddコマンドを用いてバックアップを行うことにより、ディスクの中身を完全にコピーすることができます。</p><section class="level4" aria-labelledby="ddコマンドの長所"><h4 id="ddコマンドの長所">ddコマンドの長所</h4><ul>
<li>ディスクの中身を丸ごとコピーできるため、MBR(Master Boot Record)もバックアップできます。</li>
<li>iノード番号、atime、ctimeなどの属性もバックアップできます。</li>
<li>ディスクからディスクに直接バックアップを行う場合には、ファイルシステムを介さずに直接コピーを行うので高速です。</li>
</ul></section><section class="level4" aria-labelledby="ddコマンドの短所"><h4 id="ddコマンドの短所">ddコマンドの短所</h4><ul>
<li>ディスクを丸ごとコピーするため、リストア時にファイルシステムのサイズやパラメータを変更できません。また、ファイルシステムにフラグメント（断片化）がある場合にも、そのままコピーされます。</li>
<li>バックアップの際には、ファイル変更を避けるためアンマウントする必要があります。</li>
</ul></section></section><section class="level3" aria-labelledby="dumpコマンド"><h3 id="dumpコマンド">dumpコマンド</h3><p>古くからあるバックアップ専用コマンド。ファイルシステム単位でのバックアップを行えます。</p><section class="level4" aria-labelledby="dumpコマンドの長所"><h4 id="dumpコマンドの長所">dumpコマンドの長所</h4><ul>
<li>ファイルシステム単位でバックアップするため、効率よくバックアップができます。</li>
<li>差分／増分バックアップが簡単にできます。</li>
<li>テープへのバックアップができます。</li>
<li>iノード番号、atime、ctimeなどの属性もバックアップできます。</li>
<li>リストア時にファイルシステムのサイズやパラメータを変更できます。</li>
<li>新しいファイルシステムにリストアすれば、フラグメントを解消できます。</li>
</ul></section><section class="level4" aria-labelledby="dumpコマンドの短所"><h4 id="dumpコマンドの短所">dumpコマンドの短所</h4><ul>
<li>ディレクトリ単位やファイル単位でのバックアップはできません。</li>
<li>バックアップファイルが壊れると、一部のファイルだけを救済できません。</li>
<li>速度はあまり速くありません。</li>
<li>ext2/3/4でしか使用できません。それ以外のファイルシステムの場合、たとえばXFSにはxfsdumpなど専用のコマンドを使用する必要があります。</li>
</ul></section></section><section class="level3" aria-labelledby="tarコマンド"><h3 id="tarコマンド">tarコマンド</h3><p>「Tape Archiver」の名前の通り、元々はテープへのアーカイブを作成するためのコマンドですが、ファイルとしてアーカイブを作成することもでき、柔軟性があります。</p><section class="level4" aria-labelledby="tarコマンドの長所"><h4 id="tarコマンドの長所">tarコマンドの長所</h4><ul>
<li>ファイル単位のバックアップ、リストアができます。</li>
<li>増分バックアップができます。</li>
<li>テープへのバックアップができます。</li>
<li>バックアップデータがこわれていても、部分的に復旧できます。</li>
</ul></section><section class="level4" aria-labelledby="tarコマンドの短所"><h4 id="tarコマンドの短所">tarコマンドの短所</h4><ul>
<li>速度はあまり速くありません。</li>
<li>リストア時にiノード番号が変わるため、iノードを直接参照しているプログラムではリストアしたファイルが元のファイルと同じだと認識できません。</li>
</ul></section></section><section class="level3" aria-labelledby="rsyncコマンド"><h3 id="rsyncコマンド">rsyncコマンド</h3><p>「remote sync」の名前の通り、リモートでファイルやディレクトリを同期するために作られたコマンドですが、バックアップにも使用できます。バックアップ先としてローカルホストを指定することもできるため、ローカルにマウントされた外部ストレージにバックアップすることもできます。</p><section class="level4" aria-labelledby="rsyncコマンドの長所"><h4 id="rsyncコマンドの長所">rsyncコマンドの長所</h4><ul>
<li>ファイル単位のバックアップ、リストアができます。</li>
<li>tarコマンドよりも効率よくバックアップできます。</li>
<li>増分／差分バックアップができます。</li>
</ul></section><section class="level4" aria-labelledby="rsyncコマンドの短所"><h4 id="rsyncコマンドの短所">rsyncコマンドの短所</h4><ul>
<li>ディスクをまるごとバックアップする場合には、ddやdumpと比べて遅いです。</li>
<li>リストア時にiノード番号が変わるため、iノードを直接参照しているプログラムではリストアしたファイルが元のファイルと同じだと認識できません。</li>
</ul></section></section><section class="level3" aria-labelledby="バックアップとリストアの準備"><h3 id="バックアップとリストアの準備">バックアップとリストアの準備</h3><p>各コマンドを使用したバックアップとリストアの方法を、実際にコマンドを動かしながら解説します。</p><p>バックアップ対象を/mnt/backup_test（/dev/sdb1）、リストア先を/mnt/restore_test（/dev/sdc1）とします。</p><p>仮想マシンに仮想ハードディスクを2つ、同じサイズで追加します。追加した仮想ハードディスクを/dev/sdbと/dev/sdcとしてOSから認識できるように、仮想マシンを再起動します。</p><p>物理マシンを使用している場合には、物理ハードディスクを2台追加するか、1台の追加したハードディスクに2つのパーティション（/dev/sdb1と/dev/sdb2）を作成してください。</p><p>もし、LVMの実習で使用したハードディスク/dev/sdbをそのまま利用する場合には、アンマウントした後fdiskコマンド等でパーティションを一度削除して実習を行います。</p><p>fdiskコマンドなどで/dev/sdbにパーティション/dev/sdb1を作成し、mkfs.ext4コマンドでext4ファイルシステムで初期化した後、/mnt/backup_testにマウントします。具体的なパーティション作成手順は、LVMの実習を参照してください。ただし、この実習ではLVMは使用しないので、パーティションタイプの変更は不要です。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">fdisk</span> /dev/sdb</span></span>
<span class="token output">※パーティションを作成
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">mkfs.ext4 /dev/sdb1</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mkdir</span> /mnt/backup_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mount</span> -t ext4 /dev/sdb1 /mnt/backup_test/</span></span></code></pre><p>/mnt/backup_testディレクトリに、テスト用のディレクトリとファイルを作成しておきます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mkdir</span> /mnt/backup_test/test_dir</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">touch</span> /mnt/backup_test/test_dir/test_file</span></span></code></pre></section><section class="level3" aria-labelledby="ddコマンドを使ったバックアップ"><h3 id="ddコマンドを使ったバックアップ">ddコマンドを使ったバックアップ</h3><p>ddコマンドではファイル単位でバックアップができないため、/dev/sdbデバイス自体をバックアップします。</p><p>/dev/sdcは初期化していない状態で、ddコマンドを実行します。/dev/sdbが丸ごと/dev/sdcにバックアップされます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span>  <span class="token bash language-bash"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/sdb <span class="token assign-left variable">of</span><span class="token operator">=</span>/dev/sdc</span></span>
<span class="token output">208896+0 records in
208896+0 records out
106954752 bytes (107 MB) copied, 1.29132 s, 82.8 MB/s</span></code></pre><p>fdiskコマンドを使って、/dev/sdc1が作成されていることをパーティション情報で確認します。/dev/sdcに書き込まれたパーティション情報をOSに認識させるためにOSの再起動を行ってから、確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">reboot</span></span></span>
<span class="token output">※システム再起動後に確認
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">fdisk</span> /dev/sdc</span></span>
<span class="token output">（略）
コマンド (m でヘルプ): ※p ←パーティション情報表示のpを入力

ディスク /dev/sdc: 106 MB, 106954752 バイト
ヘッド 255, セクタ 63, シリンダ 13
Units = シリンダ数 of 16065 * 512 = 8225280 バイト
セクタサイズ (論理 / 物理): 512 バイト / 4096 バイト
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
ディスク識別子: 0x43b56949

デバイス ブート      始点        終点     ブロック   Id  システム
/dev/sdc1               1          13      104391   83  Linux
Partition 1 does not start on physical sector boundary.

コマンド (m でヘルプ): ※q ←終了のqを入力</span></code></pre><p>/dev/sdc1を/mnt/restore_testとしてマウントします。先ほど/mnt/backup_testディレクトリ以下に作成したテスト用のディレクトリおよびファイルがリストアされているのが確認できます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mount</span> /dev/sdc1 /mnt/restore_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token builtin class-name">cd</span> /mnt/restore_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l</span></span>
<span class="token output">合計 14
drwx------. 2 root root 12288 12月 22 13:16 2014 lost+found
drwxr-xr-x. 3 root root  1024 12月 22 13:16 2014 test_dir
</span><span class="token command"><span class="token info punctuation"><span class="token user">[root@server restore_test]</span></span><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l test_dir/</span></span>
<span class="token output">合計 0
-rw-r--r--. 1 root root 0  12月 22 13:16 2014 test_file</span></code></pre></section><section class="level3" aria-labelledby="dumpコマンドによるバックアップ"><h3 id="dumpコマンドによるバックアップ">dumpコマンドによるバックアップ</h3><p>dumpコマンドによるバックアップはファイルシステム単位で行います。バックアップ対象の選択は、設定ファイル/etc/fstabで行います。</p><p>ここでは例として/bootディレクトリ全体をファイルとしてバックアップします。/bootディレクトリは、/（ルート）ディレクトリとは別のパーティションにファイルシステムが作られて/bootディレクトリにマウントされているので、/bootディレクトリ以下をすべてdumpコマンドでバックアップできます。</p><p>CentOS 6ではdumpコマンドが標準でインストールされていないため、dumpパッケージをインストールします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">yum <span class="token function">install</span> dump</span></span></code></pre><p>dumpコマンドによるバックアップ対象を/etc/fstabに設定します。/etc/fstabの5番目のフィールド（後から2番目）が「1」に設定されているファイルシステムがdumpコマンドの対象となります。/bootディレクトリにマウントされるファイルシステムがdumpコマンドの対象になっていることを確認します。/procや/sysなどの擬似ファイルシステムは対象外となります。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">vi</span> /etc/fstab</span></span>

<span class="token output">/dev/mapper/vg_cent65-lv_root /                       ext4    defaults
1 1
UUID=fe4d3f56-a570-44b4-a863-418b789b42bc /boot                   ext4
defaults        ※1※ 2
/dev/mapper/vg_cent65-lv_swap swap                    swap    defaults
0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0</span></code></pre><p>dumpコマンドを実行して、/bootディレクトリをバックアップします。通常はテープなどのバックアップメディアに対してバックアップを行いますが、dumpコマンドの出力をパイプでddコマンドに渡すことでファイルとしてバックアップできます。<br>
付与しているオプションの意味は以下の通りです。例では、出力先に標準出力である「-」（ハイフン）を指定している点に注意してください。</p>




























<table><thead><tr><th>オプション</th><th>意味</th></tr></thead><tbody><tr><td>-0</td><td>レベル0のバックアップを取得する。レベル0はフルバックアップ</td></tr><tr><td>-u</td><td>バックアップ完了後、/etc/dumpdatesを更新。差分バックアップに必要</td></tr><tr><td>-a</td><td>自動サイズ。バックアップメディアから終了通知があるまで書き込む</td></tr><tr><td>-n</td><td>operatorグループに対して通知を行う</td></tr><tr><td>-f</td><td>出力先を指定</td></tr></tbody></table><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash">dump -0uan -f - /boot <span class="token operator">|</span> <span class="token function">dd</span> <span class="token assign-left variable">of</span><span class="token operator">=</span>/tmp/boot.dump</span></span>
<span class="token output">  DUMP: No group entry for operator.
  DUMP: Date of this level 0 dump: Thu Jan 15 00:07:19 2015
  DUMP: Dumping /dev/sda1 (/boot) to standard output
（略）
  DUMP: Date this dump completed:  Thu Jan 15 00:07:20 2015
  DUMP: Average transfer rate: 26570 kB/s
  DUMP: DUMP IS DONE
53140+0 records in
53140+0 records out
27207680 bytes (27 MB) copied, 0.202273 s, 135 MB/s

</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/boot.dump</span></span>
<span class="token output">-rw-r--r--. 1 root root 27207680  1月 15 00:07 2015 /tmp/boot.dump</span></code></pre><p>restoreコマンドを実行して、/tmp/restore_testディレクトリにリストアします。-rオプションは、ファイルシステムをすべてリストアすることを指定しています。-fオプションは、入力として標準入力である「-」（ハイフン）を指定しています。dumpコマンドで作成したバックアップファイルをcatコマンドで読み込み、標準出力をパイプでrestoreコマンドの標準入力に渡しています。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">mkdir</span> /tmp/restore_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token builtin class-name">cd</span> /tmp/restore_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">cat</span> /tmp/boot.dump <span class="token operator">|</span> restore -rf -</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span></span></span>
<span class="token output">System.map-2.6.32-504.el6.x86_64  initramfs-2.6.32-504.el6.x86_64.img
config-2.6.32-504.el6.x86_64      lost+found
efi                               symvers-2.6.32-504.el6.x86_64.gz
grub                              vmlinuz-2.6.32-504.el6.x86_64</span></code></pre><p>/tmp/restore_testディレクトリ内のファイルをすべて削除します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">rm</span> -rf /tmp/restore_test/*</span></span></code></pre></section><section class="level3" aria-labelledby="tarコマンドによるバックアップ"><h3 id="tarコマンドによるバックアップ">tarコマンドによるバックアップ</h3><p>tarコマンドはファイル、ディレクトリをアーカイブとしてひとまとめにしてバックアップが行えます。バックアップを目的とした使用のほか、たとえばLinuxカーネルのソースコードなどを一つにまとめて配布する目的でも使用されています。</p><p>/bootディレクトリ以下のファイルおよびディレクトリをバックアップします。アーカイブファイルは/tmp/boot_backup.tarとします。アーカイブの作成は、tarコマンドに-cオプションを付与して実行します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">tar</span> -cvf /tmp/boot_backup.tar /boot</span></span>
<span class="token output">tar: メンバ名から先頭の `/' を取り除きます
/boot/
/boot/grub/
（略）
/boot/System.map-2.6.32-504.el6.x86_64
/boot/.vmlinuz-2.6.32-504.el6.x86_64.hmac

</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/boot_backup.tar</span></span>
<span class="token output">-rw-r--r--. 1 root root 26982400  1月 15 00:15 2015 /tmp/boot_backup.tar</span></code></pre><p>/tmp/restore_testディレクトリにファイルをリストアします。アーカイブからのファイルの取り出しは、tarコマンドに-xオプションを付与して実行します。ファイルはカレントディレクトリ以下に展開されます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token builtin class-name">cd</span> /tmp/restore_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">tar</span> -xvf /tmp/boot_backup.tar</span></span>
<span class="token output">boot/
boot/grub/
（略）
boot/System.map-2.6.32-504.el6.x86_64
boot/.vmlinuz-2.6.32-504.el6.x86_64.hmac
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l</span></span>
<span class="token output">合計 4
dr-xr-xr-x. 5 root root 4096  1月  6 06:20 2015 boot
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> boot/</span></span>
<span class="token output">System.map-2.6.32-504.el6.x86_64  initramfs-2.6.32-504.el6.x86_64.img
config-2.6.32-504.el6.x86_64      lost+found
efi                               symvers-2.6.32-504.el6.x86_64.gz
grub                              vmlinuz-2.6.32-504.el6.x86_64</span></code></pre><p>/tmp/restore_testディレクトリ内のファイルを削除します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">rm</span> -rf /tmp/restore_test/*</span></span></code></pre></section><section class="level3" aria-labelledby="rsyncコマンドによるバックアップ"><h3 id="rsyncコマンドによるバックアップ">rsyncコマンドによるバックアップ</h3><p>rsyncコマンドは、ファイル、ディレクトリをバックアップすることができます。ネットワーク経由で別のホストへバックアップを行うなどの用途に使用します。特徴として、新たに追加されたファイルのみバックアップすることができます。</p><p>以下の例では、同一ホスト内で/bootディレクトリ内のファイルを別のディレクトリにバックアップしています。</p><p>rsyncコマンドを実行して、/bootディレクトリを/tmp/restore_testディレクトリ以下にバックアップします。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">rsync</span> -av /boot /tmp/restore_test</span></span>
<span class="token output">sending incremental file list
boot/
boot/.vmlinuz-2.6.32-504.el6.x86_64.hmac
（略）
boot/grub/xfs_stage1_5
boot/lost+found/

sent 26964672 bytes  received 457 bytes  53930258.00 bytes/sec
total size is 26959690  speedup is 1.00</span></code></pre><p>/tmp/restore_testディレクトリ以下のファイルを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/restore_test</span></span>
<span class="token output">合計 4
dr-xr-xr-x. 5 root root 4096  1月  6 06:20 2015 boot
</span><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/restore_test/boot</span></span>
<span class="token output">合計 25848
-rw-r--r--. 1 root root  2544748 10月 15 13:54 2014 System.map-2.6.32-504.el6.x86_64
-rw-r--r--. 1 root root   106308 10月 15 13:54 2014 config-2.6.32-504.el6.x86_64
（略）
-rw-r--r--. 1 root root   200191 10月 15 13:55 2014 symvers-2.6.32-504.el6.x86_64.gz
-rwxr-xr-x. 1 root root  4152336 10月 15 13:54 2014 vmlinuz-2.6.32-504.el6.x86_64</span></code></pre><p>/boot/rsync_testファイルを新規に作成します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">touch</span> /boot/rsync_test</span></span>
<span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /boot/rsync_test</span></span>
<span class="token output">-rw-r--r--. 1 root root 0  1月 15 00:23 2015 /boot/rsync_test</span></code></pre><p>再度rsyncコマンドを実行します。新たに追加されたファイルのみバックアップされます。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">rsync</span> -av /boot /tmp/restore_test</span></span>
<span class="token output">sending incremental file list
boot/
boot/rsync_test

sent 832 bytes  received 40 bytes  1744.00 bytes/sec
total size is 26959690  speedup is 30917.08</span></code></pre><p>新たにバックアップされたファイルを確認します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">ls</span> -l /tmp/restore_test/boot/rsync_test</span></span>
<span class="token output">-rw-r--r--. 1 root root 0  1月 15 00:23 2015 /tmp/restore_test/boot/rsync_test</span></code></pre><p>tmp/restore_testディレクトリ内のファイルを削除します。</p><pre class="language-shell-session"><code class="language-shell-session"><span class="token command"><span class="token shell-symbol important">#</span> <span class="token bash language-bash"><span class="token function">rm</span> -rf /tmp/restore_test/*</span></span></code></pre></section></section></section>
</body>
</html>
