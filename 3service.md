# サービスの管理
## OSが起動するまでのプロセス
マシンに電源を入れた後、以下のような順番でシステムの初期化が行われ、OSが起動します。

1. 電源オン
1. BIOS起動とハードウェアの初期化
1. ブートローダー（GRUB）の起動
1. Linuxカーネルイメージの読み込み
1. initプロセスの起動
1. 各種サービスの起動
1. OS起動

### ブートローダーGRUBの起動
マシンの電源をオンにすると、BIOSが起動してハードウェアの初期化が行われ、起動に使用するブートデバイス（ハードディスクなど）が決定します。ブートデバイスからブートローダーであるGRUBが読み込まれ、起動処理が引き継がれます。
GRUBは、Linuxカーネルのイメージをメモリ上にロードする役割を持っています。

![GRUB選択画面](grubmenu.png)

Linuxカーネルイメージが複数ある場合は、GRUBの初期画面が表示されている時に何かキーを入力すると、GRUBのメニュー画面が表示されます。ロードしたいイメージを選択して、Enterキーを押します。


### GRUB設定ファイル
GRUBの設定ファイルは、/boot/grub/grub.confです。
普段は設定変更をすることはまずありませんが、システムに何かトラブルが発生した場合には設定を変更します。また、GRUBメニューから一時的にパラメーターを変更することもできます。たとえばシングルユーザモードで起動する処理はトラブルシューティングを行う際によく行う操作です。

```shell-session
# cat /boot/grub/grub.conf
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, eg.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/mapper/vg_server-lv_root
#          initrd /initrd-[generic-]version.img
#boot=/dev/sda
default=0
timeout=5
splashimage=(hd0,0)/grub/splash.xpm.gz
hiddenmenu
title CentOS 6 (2.6.32-504.el6.x86_64)
	root (hd0,0)
	kernel /vmlinuz-2.6.32-504.el6.x86_64 ro root=/dev/mapper/vg_server-lv_root rd_LVM_LV=vg_server/lv_swap rd_NO_LUKS rd_LVM_LV=vg_server/lv_root rd_NO_MD crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=jp106 LANG=ja_JP.UTF-8 rd_NO_DM rhgb quiet
	initrd /initramfs-2.6.32-504.el6.x86_64.img
```

設定の意味は以下の通りです。

#### default=0
timeout行で指定したタイムアウト値が経過したときの、デフォルトのカーネルイメージを選択します。
「0」の場合、最初のtitle設定以降で指定されているカーネルイメージがデフォルトになります。

#### timeout=5
GRUB選択画面のタイムアウトを設定します。
「5」の場合、タイムアウト値は5秒間になり、それを過ぎるとデフォルトのカーネルイメージが選択されます。

#### splashimage=(hd0,0)/grub/splash.xpm.gz
GRUBメニューの背景画面を指定します。不要の場合はコメントアウトします。

#### hiddenmenu
キーが押されるまでGRUBのメニューを表示しないようにします。

#### title CentOS 6 (2.6.32-504.el6.x86_64)
GRUBのメニューに表示されるタイトルを設定します。title設定から、次のtitle設定までが1つの括りとして扱われます。

#### root (hd0,0)
起動するパーティションを指定します。パーティションの指定方法は以下のようになります。GRUBでは、デバイス番号やパーティション番号は1からではなく0からカウントされることに注意してください。

```
(デバイスのタイプ デバイス番号,パーティション番号)
```

#### デバイスのタイプ
HDDやSSDの場合、接続インターフェース規格（SATA、SCSI、IDEなど）に関係なく、全て「hd」で始まります。現在は殆ど使用することはありませんが、フロッピーディスクの場合は「fd」で始まります。

#### デバイス番号
BIOSデバイス番号を指定します。0から始まり、1番目のディスクは「hd0」、2番目のディスクは「hd1」、3番目は「hd2」のように指定します。

#### パーティション番号
パーティションを指定します。「(hd0,0)」は一番目のドライブにある、1番目のパーティションを指定しています。

#### kernel /vmlinuz-2.6.32-504.el6.x86_64
起動するカーネルを指定します。
後ろには各種カーネルパラメータの指定が記述されています。

#### initrd /initramfs-2.6.32-504.el6.x86_64.img
初期化RAMディスクを指定します。

### カーネルバージョンの読み方
カーネルバージョンが「2.6.32-431.11.2.el6.x86_64」であった場合、バージョンは以下のように読みます。

```
メジャーバージョン.マイナーバージョン.リビジョン番号-リリース番号
```

#### メジャーバージョン：※2※.6.32-504.el6.x86_64
カーネルのメジャーバージョンです。
最新のメージャーバージョンは3です。

#### マイナーバージョン：2.※6※.32-504.el6.x86_64
バージョン2系では偶数が安定版、奇数の場合は開発用カーネルを意味していました。
バージョン3系では安定版のバージョンアップのたびにマイナーバージョン番号が1つずつ上がるルールに変更されました。

#### リビジョン番号：2.6.※32※-504.el6.x86_64
機能追加などがあったときにリビジョン番号が上がります。

#### リリース番号：2.6.32-※504.el6※.x86_64
パッケージが新しくなった時にリリース番号が上がります。
リリース番号の後ろにはLinuxディストリビューションの識別子が含まれます。CentOS 6のベースになっているディストリビューションがRed Hat Enterprise Linux 6であるため、「el6」となっています。

#### アーキテクチャー: 2.6.32-504.el6.※x86_64※
CPUのアーキテクチャーです。「x86_64」は64ビットを表しています。

### カーネルの起動
GRUBで指定されたLinuxカーネルイメージがメモリに読み込まれて、カーネルが起動します。カーネルはハードウェアを初期化し、カーネルの各種機能を有効にしていきます。

カーネルは必要に応じてモジュールを読み込みますが、モジュールは初期化RAMディスク（initramfs）に含まれています。カーネルは初期化RAMディスクをメモリに読み込み、仮のルートファイルシステムとして利用可能にすることで、必要となるモジュールのファイルが読み込めるようになります。

#### dmesgによるカーネル起動時の動作の確認
カーネルが起動する際の動作の様子は、dmesgコマンドで確認できます。

```shell-session
# dmesg
Initializing cgroup subsys cpuset
Initializing cgroup subsys cpu
Linux version 2.6.32-504.el6.x86_64 (mockbuild@c6b9.bsys.dev.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) ) #1 SMP Wed Oct 15 04:27:16 UTC 2014
Command line: ro root=/dev/mapper/vg_server-lv_root rd_LVM_LV=vg_server/lv_swap rd_NO_LUKS rd_LVM_LV=vg_server/lv_root rd_NO_MD crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=jp106 LANG=ja_JP.UTF-8 rd_NO_DM rhgb quiet
KERNEL supported cpus:
  Intel GenuineIntel
  AMD AuthenticAMD
  Centaur CentaurHauls
Disabled fast string operations
BIOS-provided physical RAM map:
 BIOS-e820: 0000000000000000 - 000000000009ec00 (usable)
（略）
```

### initプロセスの起動とランレベル
カーネルイメージが起動された後は、initプロセスが起動されます。
initプロセスには全てのプロセスを起動する役割があります。

initプロセスが起動するプロセスは、ランレベルによって区別されています。ランレベルとは、下表の通りOSの動作モードを表します。
デフォルトのランレベルは/etc/inittabファイルで設定され、システム起動時に設定されたランレベルで指定されている各種サービスが起動します。サービスは、システムを初期化するためのプロセスを実行したり、サーバのためのデーモンプロセスが起動したりします。

ランレベルの動作モードは、Linuxのディストリビューションにより多少異なります。以下ではCentOS 6でのランレベルを紹介します。

|ランレベル|状態|
|-------|-------|
|0|システムの停止|
|1|シングルユーザモード|
|2|未使用（ユーザ定義可能）|
|3|マルチユーザモード（コンソールログイン）|
|4|未使用（ユーザ定義可能）|
|5|マルチユーザモード（グラフィカルログイン）|
|6|システムの再起動|

#### ランレベル0
システムを停止します。ランレベル0の状態にするには、以下のコマンドを実行します。

```shell-session
# init 0
# telinit 0
```

shutdownコマンドに–hオプションを付け、シャットダウンする時間を指定する方法もあります。
今すぐサーバを停止する場合は以下のコマンドを実行します。

```shell-session
# shutdown -h now
```

haltコマンドでも同様に、すぐにシャットダウンを実行します。shutdownコマンドの-hオプションはhaltを意味しています。

```shell-session
# halt
```

#### ランレベル1
シングルユーザモードと呼ばれ、主にメンテナンス時に使用されます。
シングルユーザモードではrootユーザのみログインが許可されます。ネットワークやデーモンは起動されず、コンソール上での操作となります。
ユーザのローカルファイルシステムはマウントされます。

シングルユーザモードにするには、rootユーザで以下のコマンドを実行します。

```shell-session
# telinit 1
# init 1
```

rootのパスワードを忘れてしまった場合や、システムの設定変更後に正常に起動できなくなってしまった場合などのトラブルシューティングのためにシングルユーザーモードで起動することもできます。起動方法は6章で解説します。

#### ランレベル2、ランレベル4
基本的には未使用です。
ユーザが独自に定義することも可能です。

#### ランレベル3
全ユーザがログイン可能なマルチユーザモードです。デーモンもネットワークも起動されている状態で、CUIによる操作が可能です。

ランレベル3にするには、以下のコマンドを実行します。

```shell-session
# telinit 3
# init 3
```

#### ランレベル5
ランレベル3のマルチユーザモードに加え、グラフィカルログインが可能な状態です。
ランレベル3からランレベル5にするには、以下のコマンドでX Window Systemを起動します。

```shell-session
# startx
```

または、以下のコマンドでも実行可能です。

```shell-session
# telinit 5
# init 5
```

#### ランレベル6
システムを再起動します。
再起動後は/etc/inittabファイルで指定されたデフォルトのランレベルで起動されます。

以下のコマンドはいずれも再起動をするためのコマンドです。

```shell-session
# telinit 6
# init 6
# reboot
# shutdown –r now
```

### ランレベルの確認
現在のランレベルはrunlevelコマンドを使って確認します。

```shell-session
# runlevel
N 5
```

左から、直前のランレベルと現在のランレベルになります。起動時のランレベルが5に指定されているのが分かります。起動直後など直前のランレベルがない場合は「N」と表示されます。

次にランレベルを変更します。telinitコマンドを使用します。
ランレベルを「5」から「3」に変更します。GUIでログインしている場合、ログアウトしてCUIのログインプロンプトが表示されます。

```shell-session
# telinit 3
```

CUIログイン後、runlevelコマンドを実行すると、左から直前のランレベル5、現在のランレベル3が表示されます。

```shell-session
# runlevel

5 3
```

### デフォルトのランレベルを変更する
デフォルトのランレベルを変更したいとき、/etc/inittabファイルのデフォルト設定を変更します。
変更の際、/etc/inittabファイルの編集ミスに十分注意して下さい。設定を間違えてしまうと、システムにログインできなくなる危険性があります。

```shell-session
# vi /etc/inittab
id:※3※:initdefault: ※←5を3に変更
```

上記の設定にすると、起動時のランレベルがCUIになります。
設定変更後、システムを再起動します。

```shell-session
# reboot
```

デフォルトのランレベルがCUIになったことを確認できたら、元の設定であるランレベル5をに戻します。

```shell-session
# vi /etc/inittab
id:※5※:initdefault: ※←3を5に変更
```

```shell-session
# reboot
```

## サービスの管理
Linuxはバックグラウンドで動作する様々なサービスによって、サーバなどの機能を実現しています。必要なサービスを起動し、不要なサービスを停止することで、CPUやメモリなどのリソースが節約でき、セキュリティも向上します。

### サービスの手動制御
サービスを手動で制御するときは、serviceコマンドを使用します。
以下の例では、Webサーバであるhttpdサービスを制御します。

#### サービスの起動
serviceコマンドに、起動するサービス名httpdとstartを引数として指定して実行すると、Webサーバのサービスが起動します。

```shell-session
# service httpd start
httpd を起動中:                                            [  OK  ]
```

#### サービスステータスの確認
httpdサービスのステータスを確認します。

```shell-session
# service httpd status
httpd (pid  5234) を実行中...
```

#### サービスの再起動
httpdサービスを再起動するときは restartオプションを使用します。たとえば、設定ファイルを書き換えた場合などには、サービスの再起動が必要となります。

```shell-session
# service httpd restart
httpd を停止中:                                            [  OK  ]
httpd を起動中:                                            [  OK  ]
```

#### サービスの停止
httpdサービスを停止します。

```shell-session
# service httpd stop
httpd を停止中:                                            [  OK  ]
```

### サービス自動起動の一覧表示
OS起動時に自動的にサービスが起動するように設定するには、chkconfigコマンドを使用します。
chkconfigコマンドに--listオプションをつけて実行すると、どのサービスがOS起動後に自動的に起動するのか、ランレベル別にリスト表示されます。

```shell-session
# chkconfig --list
NetworkManager 	0:off	1:off	2:off	3:off	4:off	5:off	6:off
abrt-ccpp      	0:off	1:off	2:off	3:on	4:off	5:on	6:off
abrtd          	0:off	1:off	2:off	3:on	4:off	5:on	6:off
（略）
```

特定のサービスについて確認するときは、サービス名を指定します。

```shell-session
# chkconfig --list httpd
httpd           0:off   1:off   2:off   3:off   4:off   5:off   6:off
```

上記の場合、httpdはどのランレベルでも自動起動せず停止している状態になっています。

### サービスの自動起動の有効化
サービスの自動起動を有効にするには、chkconfigコマンドの引数に対象のサービスとonを指定して実行します。

```shell-session
# chkconfig httpd on
# chkconfig --list httpd
httpd           0:off   1:off   2:on    3:on    4:on    5:on    6:off
```

chkconfigコマンドはランレベル2、3、4、5をまとめてonに設定します。Linuxは通常ランレベル3かランレベル5で起動するので、どちらの場合でもサービスは自動起動することになります。これでLinux起動時にhttpdが自動的に起動するようになります。

### サービスの自動起動の無効化
Linuxの起動時にサービスを無効化した状態にしておきたい場合、chkconfigコマンドの引数に対象のサービスとoffを指定して実行します。

```shell-session
# chkconfig httpd off
# chkconfig --list httpd
httpd           0:off   1:off   2:off   3:off   4:off   5:off   6:off
```

これでhttpdサービスは起動時に自動的に起動しないようになりました。

### サービス起動スクリプト
serviceコマンドを実行すると、引数として指定された名前の起動スクリプトを呼び出して制御処理を行っています。起動スクリプトは、/etc/rc.d/init.dディレクトリ以下に配置されています。

```shell-session
# ls /etc/rc.d/init.d/
NetworkManager    dhcpd         kdump         portreserve  single
abrt-ccpp         dhcpd6        killall       postfix      smartd
abrt-oops         dhcrelay      lvm2-lvmetad  psacct       snmpd
abrtd             dhcrelay6     lvm2-monitor  quota_nld    snmptrapd
acpid             dnsmasq       mdmonitor     rdisc        spice-vdagentd
atd               firstboot     messagebus    restorecond  sshd
auditd            functions     netconsole    rngd         sssd
autofs            haldaemon     netfs         rpcbind      sysstat
blk-availability  halt          network       rpcgssd      udev-post
bluetooth         htcacheclean  nfs           rpcidmapd    wdaemon
certmonger        httpd         nfslock       rpcsvcgssd   winbind
cpuspeed          ip6tables     ntpd          rsyslog      wpa_supplicant
crond             iptables      ntpdate       sandbox      ypbind
cups              irqbalance    oddjobd       saslauthd
```

### ランレベルと起動スクリプトの関係
/etc/rc.d/init.dディレクトリ以下にある起動スクリプトだけでは、指定したランレベルでのサービス起動の有無や起動、停止の順序を決めることができません。Linuxでは、/etc/rc.dディレクトリ以下にランレベル毎にディレクトリを作成し、その中に起動スクリプトへのシンボリックリンクを配置しています。たとえば、ランレベル5の場合にはrc5.dという名前でディレクトリが作成されます。

```shell-session
# ls /etc/rc.d
init.d  rc.local    rc0.d  rc2.d  rc4.d  rc6.d
rc      rc.sysinit  rc1.d  rc3.d  rc5.d
```

/etc/rc.d/rc5.dディレクトリ以下の内容を確認します。

```shell-session
# ls /etc/rc.d/rc5.d/
K01smartd        K69rpcsvcgssd      S08iptables          S26haldaemon
K02oddjobd       K73winbind         S10network           S26udev-post
K05wdaemon       K75ntpdate         S11auditd            S28autofs
K10psacct        K75quota_nld       S11portreserve       S50bluetooth
K10saslauthd     K76ypbind          S12rsyslog           S55sshd
K15htcacheclean  K80kdump           S13cpuspeed          S58ntpd
K15httpd         K84NetworkManager  S13irqbalance        S70spice-vdagentd
K35dhcpd         K84wpa_supplicant  S13rpcbind           S80postfix
K35dhcpd6        K87restorecond     S15mdmonitor         S82abrt-ccpp
K35dhcrelay      K88sssd            S22messagebus        S82abrtd
K35dhcrelay6     K89rdisc           S24nfslock           S90crond
K50dnsmasq       K95firstboot       S24rpcgssd           S95atd
K50netconsole    K99rngd            S25blk-availability  S99certmonger
K50snmpd         S01sysstat         S25cups              S99local
K50snmptrapd     S02lvm2-monitor    S25netfs
K60nfs           S08ip6tables       S26acpid
```

たとえば、/etc/rc.d/rc5.d/S55sshdを確認してみると、/etc/rc.d/init.d/sshdスクリプトのシンボリックリンクになっています。

```shell-session
# ls -l /etc/rc.d/rc5.d/S55sshd
lrwxrwxrwx. 1 root root 14  1月  6 06:18 2015 /etc/rc.d/rc5.d/S55sshd -> ../init.d/sshd
```

シンボリックリンク名の頭文字のアルファベットで起動（Start）と停止（Kill）を判別しています。

シンボリックリンク名の数字は実行順です。サービスを起動、停止するための順番として利用されています。telinitコマンド等でランレベルが指定されると、以下のように動作します。

1. 指定されたランレベルに対応するディレクトリが決定されます。
2. 先頭がKで始まる起動スクリプトを引数にstopを指定して実行します。ただし、/var/lock/subsysディレクトリ内に作成されているファイル名に該当するサービス名のみが対象となります。
3. 先頭がSで始まる起動スクリプトを引数にstartを指定して実行します。ただし、/var/lock/subsysディレクトリ内に作成されているファイル名に該当するサービス名は対象から除外されます。

### シェルスクリプトとしてのサービス起動スクリプト
シェルスクリプトとは、複数のコマンドをまとめて記述したスクリプトのことです。シェルスクリプトで処理を自動化し、システム運用の効率化を図ることができます。
サービス起動スクリプトも、シェルスクリプトで記述されています。サービス起動時に内部でどのような処理が行われているか、シェルスクリプトを読んでみるとよいでしょう。

Apache Webサーバのサービス起動スクリプト/etc/rc.d/init.d/httpdを読んでみる際のポイントをまとめてみました。該当する部分をスクリプト内から探してみましょう。

* シェルスクリプト/etc/rc.d/init.d/functionsを読み込みます。このfunctionsスクリプトでは、サービス起動スクリプトで使用される共通の処理が記述されています。
* スクリプトの引数として、start、stop、status、restartなどが与えられます。スクリプト内では、指定された引数に応じてcase分で処理を条件分岐させています。
* 引数にrestartを与えた場合には、単純にスクリプト内のstopとstartのファンクションを呼び出します。
* 引数にreloadを与えた場合には、killproc関数を呼び出してhttpdのプロセスに対してHUPシグナルを送っている事が分かります。プロセスはHUPシグナルを受け取ると、停止せずに設定ファイルを読み込み直します。
* 引数にconfigtestを与えた場合には、apachectl configtestコマンドを実行し、Apache Webサーバの設定ファイルをチェックできます。

### initからsystemdへの移行
2014年6月にリリースされたRed Hat Eenterprise Linux 7、そしてCentOS 7から、これまでのサービス管理であるSysV init、またはUpstartからLinux向けの新しいサービス管理マネージャーである「systemd」に置き換えられました。systemdでのサービス管理については7章で解説します。

## cronによるコマンドの自動実行
Linuxでは、コマンドを定期的に実行する仕組みとしてcronがあります。システムのバックアップ処理など、定期的に実行したい処理を自動的に行わせるのに適しています。

### crondについて
cronを使用するには、crondがバックグラウンドで実行されている必要があります。crondは毎分cronジョブの有無をチェックしています。
もしcrondが停止していると、cronジョブは実行されません。また、システムメンテナンスなどでマシンが停止しているときも、該当時間のcronジョブは実行されないことに注意してください。

crondが実行されているか、システム起動時に自動起動されるように設定されているかを確認します。

```shell-session
# service crond status
crond (pid  1720) を実行中...
# chkconfig --list crond
crond           0:off   1:off   2:on    3:on    4:on    5:on    6:off
```

### cronジョブの実行ユーザ
cronジョブには、システム管理者が設定を行うシステム全体のcronジョブと、ユーザが個別に設定を行うcronジョブの2種類があります。

システム全体のcronジョブは、設定ファイル/etc/crontabに記述されています。

ユーザが個別に設定したcronジョブは、/var/spool/cronディレクトリ内にユーザ名で設定ファイルが作成されます。ただし、/var/spool/cronディレクトリはrootユーザしかアクセスできないようにパーミッションが設定されているため、一般ユーザはcrontabコマンドを実行してcronジョブを設定します。

以下の例は、後述するcronジョブ実行の設定を行った後の結果です。

```shell-session
# ls -ld /var/spool/cron/
drwx------. 2 root root 4096 11月 23 21:43 2013 /var/spool/cron/
# ls -l /var/spool/cron/
合計 8
-rw-------. 1 root     root     28  1月 14 13:38 2015 root
-rw-------. 1 testuser testuser 37  1月 14 13:40 2015 testuser
```

### cronジョブ実行ユーザの制御
システム管理者は、設定ファイル/etc/cron.allowおよび/etc/cron.denyを使用してcrontabコマンドを実行できるユーザを制御することができます。

* /etc/cron.allowに登録されたユーザのみ、crontabコマンドの実行できます。
* /etc/cron.denyに登録されたユーザは、crontabコマンドの実行ができません。
* /etc/cron.allow、/etc/cron.denyのどちらのファイルも存在しない場合、すべてのユーザがcrontabコマンドを実行できません。
* /etc/cron.allowが存在する場合、/etc/cron.denyは無視され、/etc/cron.allowで許可されたユーザのみがcrontabコマンドを実行できます。
* /etc/cron.allowが存在するが何も記述されていない場合、すべてのユーザがcrontabコマンドを実行できません。

デフォルトでは、/etc/cron.allowは無く、/etc/cron.denyは存在しますが何も記述されていないので、すべてのユーザがcrontabコマンドを実行できます。

|/etc/cron.allow|/etc/cron.deny|実行可能なユーザ|
|-------|-------|-------|
|無し|記述無し|全てのユーザ（デフォルト）|
|無し|有り|/etc/cron.denyに記述されていないユーザ|
|無し|無し|無し|
|有り|無視される|/etc/cron.allowに記述されたユーザ|
|記述無し|無視される|無し|

### cronジョブの書式
crondに実行させる cron ジョブは、次のような書式で記述します。

```
分 時 日 月 曜日 [ユーザ名] コマンド
```

ユーザ名の指定は、システム全体のcronジョブで有効です。指定されたユーザの実行権限でコマンドが実行されます。

|項目|設定できる値|
|-------|-------|
|分|0-59|
|時|0-23|
|日|1-31|
|月|1-12|
|曜日|0-7（0,7は日曜日）|
|ユーザ名|実行ユーザのユーザ名|
|コマンド|実行コマンド|

それぞれの設定値は「,」（カンマ）で区切ることで複数指定できます。また、「/」（スラッシュ）で間隔を指定できます。

#### 毎時0分と30分にexample.shを実行する
0,30 * * * * example.sh

#### 10分間隔でexample.shを実行する
*/10 * * * * example.sh

### crontabコマンドを使ったcronジョブの設定
cronジョブの設定は、crontabコマンドを使って行います。

|crontabコマンドオプション|説明|
|-------|-------|
|-e|crontabを編集|
|-l|登録されているcrontabを表示|
|-r|登録されているcrontabを削除|
|-u ユーザ名|ユーザを指定してcrontabコマンドを実行（rootユーザのみ実行可能）|

crontabコマンドに-eオプションを付けて実行すると、cronジョブの編集を行うためにエディタ（通常はviエディタ）が起動します。cronジョブの書式に従って記述し、最後に保存を行うと反映されます。保存時に書式がチェックされ、誤りがあると再度編集を行うか確認されるので、再度編集する場合には「y」を入力します。

```shell-session
# crontab -e
```

viエディタが起動するが起動するので、以下のように入力し、:wqで保存、終了します。

```
0 0 * * * /root/crontest.sh
```

正しい書式でcronジョブを記述した場合、以下のメッセージが表示されます。

```
crontab: installing new crontab
```

間違った書式でcronジョブを記述した場合、以下のメッセージが表示されます。

```
crontab: installing new crontab
"/tmp/crontab.2dEukI":1: bad day-of-week
errors in crontab file, can't install.
Do you want to retry the same edit? ※y ←yと入力すると編集に戻る※
```

ユーザtestuserでも同様にcronジョブを設定しておきます。suコマンドでユーザtestuserに切り替え、crontab -eコマンドを実行します。

```shell-session
# su - testuser
$ crontab -e
```

記述する内容

```
0 0 * * * /home/testuser/crontest.sh
```

exitコマンドでrootユーザに戻します。

```shell-session
$ exit
logout
#
```

### cron ジョブの一覧
登録されているcronジョブを表示します。

```shell-session
# crontab -l
0 0 * * * /root/crontest.sh
```

rootユーザは、-uオプションでユーザを指定することでその他のユーザのcronジョブを表示できます。

```shell-session
# crontab -u testuser -l
0 0 * * * /home/testuser/crontest.sh
```

さらに、rootユーザは-eオプションをつけて実行すると、その他のユーザのcronジョブを編集することもできます。

```shell-session
# crontab -u testuser -e
```

### cron ジョブの削除
crontab -rコマンドで、登録されているcronジョブをすべて削除できます。

```shell-session
# ls /var/spool/cron/
root  testuser
# crontab -r
# ls /var/spool/cron/
testuser
```

-rオプションも、-uオプションでユーザを指定できます。

```shell-session
# crontab -u testuser -r
# ls /var/spool/cron/
※すべて削除されたので何も表示されません
```

crontab -rコマンドを間違えて実行してcronジョブを削除してしまった場合、再度cronジョブを登録しなおす必要があります。

編集オプションの-eと削除オプションの-rは、キーボードで隣同士になっているので打ち間違いに注意が必要です。以下のように、crontab -lコマンドで登録されているcronジョブを表示して、バックアップを取得しておくことも対策の一つになります。

```shell-session
# crontab -l > ~/crontab_backup
```

### システム全体のcronジョブについて
システム全体のcronジョブの設定は、以下のファイルに分かれています。

|ファイルおよびディレクトリ|用途|実行ユーザの指定|
|-------|-------|-------|
|/var/spool/cron/root|rootユーザ用cronジョブ|rootのみ|
|/etc/crontab|システムジョブ用|root以外を指定可|
|/etc/cron.dディレクトリ以下|サービス単位のcronジョブ|root以外を指定可|
|/etc/anacrontab|システムジョブ用|rootのみ|

/etc/crontabおよび/etc/cron.dディレクトリ以下に配置するcronジョブは、root以外の実行ユーザを指定することができます。

### rootユーザ固有のcronジョブの使用
rootユーザがcrontabコマンドでcronジョブを編集すると、/var/spool/cron/rootに保存されます。前述の通り、crontabコマンド実行時の操作ミスで設定したcronジョブが全て消えてしまう危険もありますので、後述するサービス単位のジョブや、anacronを利用したシステムジョブを活用するとよいでしょう。

### /etc/crontabによるcronジョブの設定
/etc/crontabは、最も基本的なcronジョブを設定するためのファイルです。システムの運用上、決められた時間に実行する必要があるcronジョブを記述します。

ただし、CentOS 6では1時間おき、1日おき、1週間おき、1ヶ月おきに定期的に実行する仕組みが別途用意されているので、それらの間隔でcronジョブを実行したい場合には、後述する仕組みを利用する方が良いでしょう。

### サービス単位のcronジョブ
/etc/cron.dディレクトリ内には、各種サービスのために実行されるcronジョブが記述された設定ファイルが配置されています。crondが起動する際に読み込まれて、cronジョブが設定されます。

```shell-session
# ls /etc/cron.d
0hourly  raid-check  sysstat
```

/etc/cron.d/0hourlyには、1時間おき（毎時1分）に/etc/cron.hourlyディレクトリ内のシェルスクリプトが実行されるcronジョブが記述されています。1時間おきに実行したいcronジョブはこのファイルに記述しておくか、/etc/cron.hourlyディレクトリ内にシェルスクリプトを配置しておくとよいでしょう。

```shell-session
# cat /etc/cron.d/0hourly 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
01 * * * * root run-parts /etc/cron.hourly
```

/etc/cron.hourlyディレクトリ内には、後述するanacronを呼び出すスクリプトが用意されています。

```shell-session
# ls /etc/cron.hourly/
0anacron
# cat /etc/cron.hourly/0anacron 
#!/bin/bash
# Skip excecution unless the date has changed from the previous run 
if test -r /var/spool/anacron/cron.daily; then
    day=`cat /var/spool/anacron/cron.daily`
fi
if [ `date +%Y%m%d` = "$day" ]; then
    exit 0;
fi

# Skip excecution unless AC powered
if test -x /usr/bin/on_ac_power; then
    /usr/bin/on_ac_power &> /dev/null
    if test $? -eq 1; then
    exit 0
    fi
fi
/usr/sbin/anacron -s
```

/etc/cron.d/raid-checkは、ソフトウェアRAIDのチェックを行うraid-checkコマンドを、毎週日曜日の午前1時に呼び出しています。

```shell-session
# cat /etc/cron.d/raid-check 
# Run system wide raid-check once a week on Sunday at 1am by default
0 1 * * Sun root /usr/sbin/raid-check
```

/etc/cron.d/sysstatは、システムの利用状況を記録するsarを呼び出しています。10分おきに/usr/lib64/sa/sa1が実行され、23時53分に/usr/lib64/sa/sa2が実行されます。

```shell-session
# cat /etc/cron.d/sysstat 
# Run system activity accounting tool every 10 minutes
*/10 * * * * root /usr/lib64/sa/sa1 1 1
# 0 * * * * root /usr/lib64/sa/sa1 600 6 &
# Generate a daily summary of process accounting at 23:53
53 23 * * * root /usr/lib64/sa/sa2 -A
```

### anacron によるジョブの実行 
cronを使って決められた時刻に一斉にcronジョブを実行すると、システムの負荷が集中してしまう欠点があります。特にクラウド環境において同じ時刻にcronジョブが実行されてしまうと、CPUやメモリ、I/Oなどの共有リソースを複数の仮想マシンが一斉に取り合うことになります。
そこでanacronを使ってジョブを実行すると、ジョブが実行されるタイミングがランダムに決められるので、ジョブ実行が同時発生しないようになります。

anacronで実行させたいジョブはシェルスクリプトとして作成し、実行したい時間間隔に応じて以下の表のディレクトリ内に配置します。シェルスクリプトのファイルを配置するだけでジョブが定期実行されるようになるので、定期実行するジョブをパッケージのインストール時に簡単に登録できるというメリットもあります。

|実行する時間間隔|ディレクトリ|
|-------|-------|
|1日おき|/etc/cron.daily|
|1週間おき|/etc/cron.weekly|
|1ヶ月おき|/etc/cron.monthly|

### anacronの設定
anacronは、1時間おきにcrondから起動されます。起動時に設定ファイルとして/etc/anacrontabを読み込み、実行が必要なジョブを実行します。

デフォルトの設定ファイルは以下の通りです。

```shell-session
# cat /etc/anacrontab
# /etc/anacrontab: configuration file for anacron

# See anacron(8) and anacrontab(5) for details.

SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
# the maximal random delay added to the base delay of the jobs
RANDOM_DELAY=45
# the jobs will be started during the following hours only
START_HOURS_RANGE=3-22

#period in days   delay in minutes   job-identifier   command
1       5       cron.daily              nice run-parts /etc/cron.daily
7       25      cron.weekly             nice run-parts /etc/cron.weekly
@monthly 45     cron.monthly            nice run-parts /etc/cron.monthly
```

ジョブの実行頻度は、ジョブ設定の最初の数字で実行間隔を日数で記述します。デフォルトでは1日おきと7日おきのジョブが設定されています。1ヶ月毎の設定のように、実行間隔の設定は数値以外にマクロが用意されています。

|マクロ|設定値|
|-------|-------|
|@daily|1（毎日1回）|
|@weekly|7（毎週1回）|
|@monthly|毎月1回|

各ジョブは、それぞれの基準遅延時間に最大45分のランダムに決められた遅延時間（RANDOM_DELAY）を足して実行されます。基準遅延時間は、ジョブ定義の2番目の数字です。デフォルトでは、1日おきのジョブが5分、1週間おきのジョブが25分、1ヶ月おきのジョブが45分です。仮想マシン間で同時にジョブが実行されないようにしたい場合には、基準遅延時間を大きくずらす必要があります。

anacronがジョブを実行するのは、START_HOURS_RANGEで設定されている3時から22時の間です。anacronはシステムが停止していた場合、実行していなかったジョブを再起動後に実行する仕組みがあります。そのため、このようにジョブ実行時間が広く指定されています。
ただし、この設定では日中でもジョブが実行される可能性があります。もし、夜間にだけジョブを実行したい場合には、/etc/anacrontabに以下のように指定するといいでしょう。ここでは夜間の23時から翌日の朝6時までを指定しています。

```
START_HOURS_RANGE=23-6
```

## NTPによる時刻管理
コンピューターの時刻は、意外と精度が低く1日ごとに数秒狂っていきます。しかも、電源OFFにした状態だとさらに狂いやすくなります。認証やデータベース、ログを集中管理するような環境の場合には、この時刻のずれが大きな問題になる場合があります。

システムの時刻を合わせる仕組みとして、NTP（Network Time Protocol）があります。NTPを利用することで、ネットワーク上のNTPサーバから時刻を取得し、システムの時刻を正確な時刻に合わせる事ができます。

### NTPサービスのインストール
NTPクライアントに対して時刻を提供するNTPサーバを実行するには、NTPサービスをインストールします。NTPサービスは、NTPサーバとしての機能と、自分自身の時刻をNTPサーバに同期させるNTPクライアントの機能の両方を備えています。

NTPサービスがインストールされていない場合には、yumコマンドでインストールします。

```shell-session
# yum install ntp
```

### NTPサービスの起動と自動起動の有効化
NTPサービス（ntpd）を起動します。

```shell-session
# service ntpd start
```

chkconfigコマンドで自動起動を有効化します。

```shell-session
# chkconfig ntpd on
# chkconfig --list ntpd
ntpd            0:off   1:off   2:off   3:on    4:off   5:off   6:off
```

NTPサーバを起動してから、しばらくすると上位のNTPサーバと時刻同期が始まります。時刻同期は徐々に行われるため、すぐには完了しません。

### 上位NTPサーバの設定
同期する時刻を提供してくれる上位NTPサーバの設定は/etc/ntp.confに記述します。サーバは複数指定できます。CentOSでは、デフォルトでpool.ntp.orgのNTPサーバに同期するように設定されています。pool.ntp.orgはインターネット上のNTPサーバのアドレスをランダムに返すようになっています。

```
server 0.centos.pool.ntp.org iburst
server 1.centos.pool.ntp.org iburst
server 2.centos.pool.ntp.org iburst
server 3.centos.pool.ntp.org iburst
```

ntpqコマンドを実行して、外部のNTPサーバとの時刻同期の状態を確認します。

```shell-session
# ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*219x123x70x91.a 192.168.7.123    2 u  424 1024  377    2.296   -0.851   1.985
-balthasar.gimas 65.32.162.194    3 u  764 1024  377    4.574    3.282   1.737
+ntp-v6.chobi.pa 61.114.187.55    2 u  960 1024  337    1.012    0.546   1.170
+the.platformnin 22.42.17.250     3 u   46 1024  377    3.686    0.123   2.642
```

一番左に表示されているステータスの読み方は以下の通りです。

|表示|意味|
|-------|-------|
|*|同期している|
|+|いつでも同期可能|
|x|クロックが不正確なため無効|
|空白（スペース）|使用不可（通信不可、同期に時間が掛かっている等）|

### NTPクライアントからの時刻同期リクエストの制御
NTPサービスは、デフォルトではNTPクライアントからの時刻同期リクエストを受け付けないように設定されています。

以下の例では、NTPサーバの設定ファイル/etc/ntp.confに「192.168.0.0/255.255.255.0」のネットワークに属しているNTPクライアントからの時刻同期リクエストを許可するように設定しています。

```shell-session
# vi /etc/ntp.conf

# Hosts on local network are less restricted.
#restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap
※restrict 192.168.0.0 mask 255.255.255.0 nomodify notrap ←この行を追加
```

設定を変更したらntpサービスを再起動します。

```shell-session
# service ntpd restart
ntpd を停止中:                                             [  OK  ]
ntpd を起動中:                                             [  OK  ]
```

### ファイアーウォールの設定変更
NTPサーバはUDPのポート番号123番でNTPクライアントからの時刻同期リクエストを待ち受けています。iptablesでパケットフィルタリングを行っている場合、ルールを追加する必要があります。

/etc/sysconfig/iptablesを編集してルールを追加し、iptablesサービスをリロードします。

```shell-session
# vi /etc/sysconfig/iptables

# Firewall configuration written by system-config-firewall
# Manual customization of this file is not recommended.
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
※-A INPUT -m state --state NEW -m udp -p udp --dport 123 -j ACCEPT ←この行を追加※
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT
```

serviceコマンドで、iptablesサービスをリロードします。

```shell-session
# service iptables reload
iptables: Trying to reload firewall rules:                 [  OK  ]
# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
（略）
ACCEPT     udp  --  anywhere             anywhere            state NEW udp dpt:ntp 
REJECT     all  --  anywhere             anywhere            reject-with icmp-host-prohibited 
（略）
```

### NTPクライアントのNTPサービスを使ってNTPサーバと時刻を同期する
クライアントのNTPサービスは、/etc/ntp.confにserver設定で指定されたNTPサーバと時刻同期を行います。

クライアントで、デフォルトで設定されているpool.ntp.orgのserver設定をコメントアウトし、構築したNTPサーバ（192.168.0.10）と時刻を同期するように設定します。

クライアントにNTPサービスがインストールされていない場合には、yumコマンドでインストールします。

```shell-session
[root@client ~]# yum install ntp
[root@client ~]# vi /etc/ntp.conf

※#※server 0.centos.pool.ntp.org iburst ※←行頭でコメントアウト
※#※server 1.centos.pool.ntp.org iburst ※←行頭でコメントアウト
※#※server 2.centos.pool.ntp.org iburst ※←行頭でコメントアウト
※#※server 3.centos.pool.ntp.org iburst ※←行頭でコメントアウト
※server 192.168.0.10 iburst ←この行を追加
```

クライアントのNTPサービスを再起動します。

```shell-session
# service ntpd restart
ntpd を停止中:                                             [  OK  ]
ntpd を起動中:                                             [  OK  ]
```

ntpqコマンドで、時刻同期の状態を確認します。

```shell-session
[root@client ~]# ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*server          157.7.154.29     3 u    2   64    1    0.152    0.108   0.007
```


